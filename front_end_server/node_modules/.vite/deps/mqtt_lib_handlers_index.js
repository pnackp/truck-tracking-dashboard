import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/mqtt/build/lib/handlers/publish.js
var require_publish = __commonJS({
  "node_modules/mqtt/build/lib/handlers/publish.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];
    var handlePublish = (client, packet, done) => {
      client.log("handlePublish: packet %o", packet);
      done = typeof done !== "undefined" ? done : client.noop;
      let topic = packet.topic.toString();
      const message = packet.payload;
      const { qos } = packet;
      const { messageId } = packet;
      const { options } = client;
      if (client.options.protocolVersion === 5) {
        let alias;
        if (packet.properties) {
          alias = packet.properties.topicAlias;
        }
        if (typeof alias !== "undefined") {
          if (topic.length === 0) {
            if (alias > 0 && alias <= 65535) {
              const gotTopic = client["topicAliasRecv"].getTopicByAlias(alias);
              if (gotTopic) {
                topic = gotTopic;
                client.log("handlePublish :: topic complemented by alias. topic: %s - alias: %d", topic, alias);
              } else {
                client.log("handlePublish :: unregistered topic alias. alias: %d", alias);
                client.emit("error", new Error("Received unregistered Topic Alias"));
                return;
              }
            } else {
              client.log("handlePublish :: topic alias out of range. alias: %d", alias);
              client.emit("error", new Error("Received Topic Alias is out of range"));
              return;
            }
          } else if (client["topicAliasRecv"].put(topic, alias)) {
            client.log("handlePublish :: registered topic: %s - alias: %d", topic, alias);
          } else {
            client.log("handlePublish :: topic alias out of range. alias: %d", alias);
            client.emit("error", new Error("Received Topic Alias is out of range"));
            return;
          }
        }
      }
      client.log("handlePublish: qos %d", qos);
      switch (qos) {
        case 2: {
          options.customHandleAcks(topic, message, packet, (error, code) => {
            if (typeof error === "number") {
              code = error;
              error = null;
            }
            if (error) {
              return client.emit("error", error);
            }
            if (validReasonCodes.indexOf(code) === -1) {
              return client.emit("error", new Error("Wrong reason code for pubrec"));
            }
            if (code) {
              client["_sendPacket"]({ cmd: "pubrec", messageId, reasonCode: code }, done);
            } else {
              client.incomingStore.put(packet, () => {
                client["_sendPacket"]({ cmd: "pubrec", messageId }, done);
              });
            }
          });
          break;
        }
        case 1: {
          options.customHandleAcks(topic, message, packet, (error, code) => {
            if (typeof error === "number") {
              code = error;
              error = null;
            }
            if (error) {
              return client.emit("error", error);
            }
            if (validReasonCodes.indexOf(code) === -1) {
              return client.emit("error", new Error("Wrong reason code for puback"));
            }
            if (!code) {
              client.emit("message", topic, message, packet);
            }
            client.handleMessage(packet, (err) => {
              if (err) {
                return done && done(err);
              }
              client["_sendPacket"]({ cmd: "puback", messageId, reasonCode: code }, done);
            });
          });
          break;
        }
        case 0:
          client.emit("message", topic, message, packet);
          client.handleMessage(packet, done);
          break;
        default:
          client.log("handlePublish: unknown QoS. Doing nothing.");
          break;
      }
    };
    exports.default = handlePublish;
  }
});

// node_modules/mqtt/package.json
var require_package = __commonJS({
  "node_modules/mqtt/package.json"(exports, module) {
    module.exports = {
      name: "mqtt",
      description: "A library for the MQTT protocol",
      version: "5.14.1",
      contributors: [
        "Adam Rudd <adamvrr@gmail.com>",
        "Matteo Collina <matteo.collina@gmail.com> (https://github.com/mcollina)",
        "Siarhei Buntsevich <scarry0506@gmail.com> (https://github.com/scarry1992)",
        "Yoseph Maguire <yomaguir@microsoft.com> (https://github.com/YoDaMa)",
        "Daniel Lando <daniel.sorridi@gmail.com> (https://github.com/robertsLando)"
      ],
      keywords: [
        "mqtt",
        "publish/subscribe",
        "publish",
        "subscribe"
      ],
      license: "MIT",
      repository: {
        type: "git",
        url: "git://github.com/mqttjs/MQTT.js.git"
      },
      main: "./build/index.js",
      module: "./dist/mqtt.esm.js",
      bin: {
        mqtt_pub: "./build/bin/pub.js",
        mqtt_sub: "./build/bin/sub.js",
        mqtt: "./build/bin/mqtt.js"
      },
      files: [
        "dist/",
        "CONTRIBUTING.md",
        "LICENSE.md",
        "help/",
        "build/"
      ],
      exports: {
        ".": {
          "react-native": "./dist/mqtt.esm.js",
          browser: {
            import: "./dist/mqtt.esm.js",
            default: "./dist/mqtt.min.js"
          },
          default: "./build/index.js"
        },
        "./package.json": "./package.json",
        "./*.map": "./build/*.js.map",
        "./dist/*": "./dist/*.js",
        "./*": "./build/*.js"
      },
      types: "build/index.d.ts",
      typesVersions: {
        "*": {
          "*": [
            "./build/index.d.ts"
          ]
        }
      },
      scripts: {
        lint: "eslint --ext .ts .",
        "lint-fix": "eslint --fix --ext .ts .",
        "build:ts": "rimraf build/ && tsc -p tsconfig.build.json",
        "build:browser": "node esbuild.js",
        build: "npm run build:ts && npm run build:browser",
        prepare: "npm run build",
        "unit-test:node": "node -r esbuild-register --test-concurrency 4 --test-reporter=junit --test-reporter-destination=junit.xml --test-reporter=spec --test-reporter-destination=stdout --test test/node/*.ts ",
        "unit-test:browser": "wtr",
        "test:node": "node_modules/.bin/nyc npm run unit-test:node",
        "test:browser": "npm run build && npm run unit-test:browser",
        test: "npm run test:node",
        changelog: "conventional-changelog -p angular -i CHANGELOG.md -s && git add CHANGELOG.md",
        "changelog-init": "conventional-changelog -p angular -i CHANGELOG.md -s -r 0",
        release: "read -p 'GITHUB_TOKEN: ' GITHUB_TOKEN && export GITHUB_TOKEN=$GITHUB_TOKEN && release-it"
      },
      "release-it": {
        github: {
          release: true
        },
        git: {
          tagName: "v${version}",
          commitMessage: "chore(release): ${version}"
        },
        hooks: {
          "before:init": [
            "npm run test"
          ]
        },
        npm: {
          publish: true
        },
        plugins: {
          "@release-it/conventional-changelog": {
            preset: "angular",
            infile: "CHANGELOG.md"
          }
        }
      },
      publishConfig: {
        provenance: true
      },
      "pre-commit": [
        "lint"
      ],
      engines: {
        node: ">=16.0.0"
      },
      browser: {
        "./mqtt.js": "./dist/mqtt.js",
        fs: false,
        tls: false,
        net: false
      },
      dependencies: {
        "@types/readable-stream": "^4.0.21",
        "@types/ws": "^8.18.1",
        commist: "^3.2.0",
        "concat-stream": "^2.0.0",
        debug: "^4.4.1",
        "help-me": "^5.0.0",
        "lru-cache": "^10.4.3",
        minimist: "^1.2.8",
        "mqtt-packet": "^9.0.2",
        "number-allocator": "^1.0.14",
        "readable-stream": "^4.7.0",
        rfdc: "^1.4.1",
        socks: "^2.8.6",
        split2: "^4.2.0",
        "worker-timers": "^8.0.23",
        ws: "^8.18.3"
      },
      devDependencies: {
        "@eslint/eslintrc": "^3.3.1",
        "@eslint/js": "^9.32.0",
        "@esm-bundle/chai": "^4.3.4",
        "@release-it/conventional-changelog": "^10.0.1",
        "@tsconfig/node20": "^20.1.6",
        "@types/chai": "^5.2.2",
        "@types/node": "^20.17.16",
        "@types/sinon": "^17.0.4",
        "@types/tape": "^5.8.1",
        "@typescript-eslint/eslint-plugin": "^8.38.0",
        "@typescript-eslint/parser": "^8.38.0",
        "@web/test-runner": "^0.20.2",
        "@web/test-runner-playwright": "^0.11.1",
        "aedes-cli": "^0.8.0",
        chai: "^5.2.1",
        chokidar: "^4.0.3",
        "conventional-changelog-cli": "^5.0.0",
        "end-of-stream": "^1.4.5",
        esbuild: "^0.25.8",
        "esbuild-plugin-polyfill-node": "^0.3.0",
        "esbuild-register": "^3.6.0",
        eslint: "^9.32.0",
        "eslint-config-prettier": "^10.1.8",
        "eslint-plugin-import": "^2.32.0",
        "eslint-plugin-prettier": "^5.5.3",
        global: "^4.4.0",
        globals: "^16.3.0",
        "leaked-handles": "^5.2.0",
        mkdirp: "^3.0.1",
        "mqtt-connection": "^4.1.0",
        "mqtt-level-store": "^3.1.0",
        nyc: "^17.1.0",
        "pre-commit": "^1.2.2",
        prettier: "^3.6.2",
        "release-it": "^19.0.4",
        rimraf: "^6.0.1",
        should: "^13.2.3",
        sinon: "^17.0.2",
        snazzy: "^9.0.0",
        tape: "^5.9.0",
        "ts-node": "^10.9.2",
        typescript: "^5.8.3"
      }
    };
  }
});

// node_modules/mqtt/build/lib/shared.js
var require_shared = __commonJS({
  "node_modules/mqtt/build/lib/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MQTTJS_VERSION = exports.nextTick = exports.ErrorWithSubackPacket = exports.ErrorWithReasonCode = void 0;
    exports.applyMixin = applyMixin;
    var ErrorWithReasonCode = class _ErrorWithReasonCode extends Error {
      code;
      constructor(message, code) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ErrorWithReasonCode.prototype);
        Object.getPrototypeOf(this).name = "ErrorWithReasonCode";
      }
    };
    exports.ErrorWithReasonCode = ErrorWithReasonCode;
    var ErrorWithSubackPacket = class _ErrorWithSubackPacket extends Error {
      packet;
      constructor(message, packet) {
        super(message);
        this.packet = packet;
        Object.setPrototypeOf(this, _ErrorWithSubackPacket.prototype);
        Object.getPrototypeOf(this).name = "ErrorWithSubackPacket";
      }
    };
    exports.ErrorWithSubackPacket = ErrorWithSubackPacket;
    function applyMixin(target, mixin, includeConstructor = false) {
      const inheritanceChain = [mixin];
      while (true) {
        const current = inheritanceChain[0];
        const base = Object.getPrototypeOf(current);
        if (base?.prototype) {
          inheritanceChain.unshift(base);
        } else {
          break;
        }
      }
      for (const ctor of inheritanceChain) {
        for (const prop of Object.getOwnPropertyNames(ctor.prototype)) {
          if (includeConstructor || prop !== "constructor") {
            Object.defineProperty(target.prototype, prop, Object.getOwnPropertyDescriptor(ctor.prototype, prop) ?? /* @__PURE__ */ Object.create(null));
          }
        }
      }
    }
    exports.nextTick = typeof process?.nextTick === "function" ? process.nextTick : (callback) => {
      setTimeout(callback, 0);
    };
    exports.MQTTJS_VERSION = require_package().version;
  }
});

// node_modules/mqtt/build/lib/handlers/ack.js
var require_ack = __commonJS({
  "node_modules/mqtt/build/lib/handlers/ack.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReasonCodes = void 0;
    var shared_1 = require_shared();
    exports.ReasonCodes = {
      0: "",
      1: "Unacceptable protocol version",
      2: "Identifier rejected",
      3: "Server unavailable",
      4: "Bad username or password",
      5: "Not authorized",
      16: "No matching subscribers",
      17: "No subscription existed",
      128: "Unspecified error",
      129: "Malformed Packet",
      130: "Protocol Error",
      131: "Implementation specific error",
      132: "Unsupported Protocol Version",
      133: "Client Identifier not valid",
      134: "Bad User Name or Password",
      135: "Not authorized",
      136: "Server unavailable",
      137: "Server busy",
      138: "Banned",
      139: "Server shutting down",
      140: "Bad authentication method",
      141: "Keep Alive timeout",
      142: "Session taken over",
      143: "Topic Filter invalid",
      144: "Topic Name invalid",
      145: "Packet identifier in use",
      146: "Packet Identifier not found",
      147: "Receive Maximum exceeded",
      148: "Topic Alias invalid",
      149: "Packet too large",
      150: "Message rate too high",
      151: "Quota exceeded",
      152: "Administrative action",
      153: "Payload format invalid",
      154: "Retain not supported",
      155: "QoS not supported",
      156: "Use another server",
      157: "Server moved",
      158: "Shared Subscriptions not supported",
      159: "Connection rate exceeded",
      160: "Maximum connect time",
      161: "Subscription Identifiers not supported",
      162: "Wildcard Subscriptions not supported"
    };
    var handleAck = (client, packet) => {
      const { messageId } = packet;
      const type = packet.cmd;
      let response = null;
      const cb = client.outgoing[messageId] ? client.outgoing[messageId].cb : null;
      let err = null;
      if (!cb) {
        client.log("_handleAck :: Server sent an ack in error. Ignoring.");
        return;
      }
      client.log("_handleAck :: packet type", type);
      switch (type) {
        case "pubcomp":
        case "puback": {
          const pubackRC = packet.reasonCode;
          if (pubackRC && pubackRC > 0 && pubackRC !== 16) {
            err = new shared_1.ErrorWithReasonCode(`Publish error: ${exports.ReasonCodes[pubackRC]}`, pubackRC);
            client["_removeOutgoingAndStoreMessage"](messageId, () => {
              cb(err, packet);
            });
          } else {
            client["_removeOutgoingAndStoreMessage"](messageId, cb);
          }
          break;
        }
        case "pubrec": {
          response = {
            cmd: "pubrel",
            qos: 2,
            messageId
          };
          const pubrecRC = packet.reasonCode;
          if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {
            err = new shared_1.ErrorWithReasonCode(`Publish error: ${exports.ReasonCodes[pubrecRC]}`, pubrecRC);
            client["_removeOutgoingAndStoreMessage"](messageId, () => {
              cb(err, packet);
            });
          } else {
            client["_sendPacket"](response);
          }
          break;
        }
        case "suback": {
          delete client.outgoing[messageId];
          client.messageIdProvider.deallocate(messageId);
          const granted = packet.granted;
          for (let grantedI = 0; grantedI < granted.length; grantedI++) {
            const subackRC = granted[grantedI];
            if ((subackRC & 128) !== 0) {
              err = new Error(`Subscribe error: ${exports.ReasonCodes[subackRC]}`);
              err.code = subackRC;
              const topics = client.messageIdToTopic[messageId];
              if (topics) {
                topics.forEach((topic) => {
                  delete client["_resubscribeTopics"][topic];
                });
              }
            }
          }
          delete client.messageIdToTopic[messageId];
          client["_invokeStoreProcessingQueue"]();
          cb(err, packet);
          break;
        }
        case "unsuback": {
          delete client.outgoing[messageId];
          client.messageIdProvider.deallocate(messageId);
          client["_invokeStoreProcessingQueue"]();
          cb(null, packet);
          break;
        }
        default:
          client.emit("error", new Error("unrecognized packet type"));
      }
      if (client.disconnecting && Object.keys(client.outgoing).length === 0) {
        client.emit("outgoingEmpty");
      }
    };
    exports.default = handleAck;
  }
});

// node_modules/mqtt/build/lib/handlers/auth.js
var require_auth = __commonJS({
  "node_modules/mqtt/build/lib/handlers/auth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shared_1 = require_shared();
    var ack_1 = require_ack();
    var handleAuth = (client, packet) => {
      const { options } = client;
      const version = options.protocolVersion;
      const rc = version === 5 ? packet.reasonCode : packet.returnCode;
      if (version !== 5) {
        const err = new shared_1.ErrorWithReasonCode(`Protocol error: Auth packets are only supported in MQTT 5. Your version:${version}`, rc);
        client.emit("error", err);
        return;
      }
      client.handleAuth(packet, (err, packet2) => {
        if (err) {
          client.emit("error", err);
          return;
        }
        if (rc === 24) {
          client.reconnecting = false;
          client["_sendPacket"](packet2);
        } else {
          const error = new shared_1.ErrorWithReasonCode(`Connection refused: ${ack_1.ReasonCodes[rc]}`, rc);
          client.emit("error", error);
        }
      });
    };
    exports.default = handleAuth;
  }
});

// node_modules/mqtt/node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/mqtt/node_modules/lru-cache/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack2 = class _Stack {
      heap;
      length;
      // private constructor
      static #constructing = false;
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        _Stack.#constructing = true;
        const s = new _Stack(max, HeapCls);
        _Stack.#constructing = false;
        return s;
      }
      constructor(max, HeapCls) {
        if (!_Stack.#constructing) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      // options that cannot be changed without disaster
      #max;
      #maxSize;
      #dispose;
      #disposeAfter;
      #fetchMethod;
      #memoMethod;
      /**
       * {@link LRUCache.OptionsBase.ttl}
       */
      ttl;
      /**
       * {@link LRUCache.OptionsBase.ttlResolution}
       */
      ttlResolution;
      /**
       * {@link LRUCache.OptionsBase.ttlAutopurge}
       */
      ttlAutopurge;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnGet}
       */
      updateAgeOnGet;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnHas}
       */
      updateAgeOnHas;
      /**
       * {@link LRUCache.OptionsBase.allowStale}
       */
      allowStale;
      /**
       * {@link LRUCache.OptionsBase.noDisposeOnSet}
       */
      noDisposeOnSet;
      /**
       * {@link LRUCache.OptionsBase.noUpdateTTL}
       */
      noUpdateTTL;
      /**
       * {@link LRUCache.OptionsBase.maxEntrySize}
       */
      maxEntrySize;
      /**
       * {@link LRUCache.OptionsBase.sizeCalculation}
       */
      sizeCalculation;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
       */
      noDeleteOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
       */
      noDeleteOnStaleGet;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
       */
      allowStaleOnFetchAbort;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
       */
      allowStaleOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.ignoreFetchAbort}
       */
      ignoreFetchAbort;
      // computed properties
      #size;
      #calculatedSize;
      #keyMap;
      #keyList;
      #valList;
      #next;
      #prev;
      #head;
      #tail;
      #free;
      #disposed;
      #sizes;
      #starts;
      #ttls;
      #hasDispose;
      #hasFetchMethod;
      #hasDisposeAfter;
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c) {
        return {
          // properties
          starts: c.#starts,
          ttls: c.#ttls,
          sizes: c.#sizes,
          keyMap: c.#keyMap,
          keyList: c.#keyList,
          valList: c.#valList,
          next: c.#next,
          prev: c.#prev,
          get head() {
            return c.#head;
          },
          get tail() {
            return c.#tail;
          },
          free: c.#free,
          // methods
          isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
          backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
          moveToTail: (index) => c.#moveToTail(index),
          indexes: (options) => c.#indexes(options),
          rindexes: (options) => c.#rindexes(options),
          isStale: (index) => c.#isStale(index)
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return this.#max;
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return this.#maxSize;
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return this.#calculatedSize;
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return this.#size;
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return this.#fetchMethod;
      }
      get memoMethod() {
        return this.#memoMethod;
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return this.#dispose;
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return this.#disposeAfter;
      }
      constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!this.#maxSize && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (memoMethod !== void 0 && typeof memoMethod !== "function") {
          throw new TypeError("memoMethod must be a function if defined");
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = /* @__PURE__ */ new Map();
        this.#keyList = new Array(max).fill(void 0);
        this.#valList = new Array(max).fill(void 0);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack2.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === "function") {
          this.#dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.#disposeAfter = disposeAfter;
          this.#disposed = [];
        } else {
          this.#disposeAfter = void 0;
          this.#disposed = void 0;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.#maxSize !== 0) {
            if (!isPosInt(this.#maxSize)) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.#initializeTTLTracking();
        }
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Return the number of ms left in the item's TTL. If item is not in cache,
       * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
       */
      getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
      }
      #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
          starts[index] = ttl !== 0 ? start : 0;
          ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.#isStale(index)) {
                this.#delete(this.#keyList[index], "expire");
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.#updateItemAge = (index) => {
          starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
          if (ttls[index]) {
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start)
              return;
            status.ttl = ttl;
            status.start = start;
            status.now = cachedNow || getNow();
            const age = status.now - start;
            status.remainingTTL = ttl - age;
          }
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.#keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start) {
            return Infinity;
          }
          const age = (cachedNow || getNow()) - start;
          return ttl - age;
        };
        this.#isStale = (index) => {
          const s = starts[index];
          const t = ttls[index];
          return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
      }
      // conditionally set private methods related to TTL
      #updateItemAge = () => {
      };
      #statusTTL = () => {
      };
      #setItemTTL = () => {
      };
      /* c8 ignore stop */
      #isStale = () => false;
      #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index) => {
          this.#calculatedSize -= sizes[index];
          sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
          if (this.#isBackgroundFetch(v)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
            } else {
              throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
            }
          }
          return size;
        };
        this.#addItemSize = (index, size, status) => {
          sizes[index] = size;
          if (this.#maxSize) {
            const maxSize = this.#maxSize - sizes[index];
            while (this.#calculatedSize > maxSize) {
              this.#evict(true);
            }
          }
          this.#calculatedSize += sizes[index];
          if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = this.#calculatedSize;
          }
        };
      }
      #removeItemSize = (_i) => {
      };
      #addItemSize = (_i, _s, _st) => {
      };
      #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
        return 0;
      };
      *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#tail; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#head) {
              break;
            } else {
              i = this.#prev[i];
            }
          }
        }
      }
      *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#head; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#tail) {
              break;
            } else {
              i = this.#next[i];
            }
          }
        }
      }
      #isValidIndex(index) {
        return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i of this.#indexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i of this.#rindexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i of this.#indexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i of this.#rindexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * A String value that is used in the creation of the default string
       * description of an object. Called by the built-in method
       * `Object.prototype.toString`.
       */
      [Symbol.toStringTag] = "LRUCache";
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
       */
      find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, this.#keyList[i], this)) {
            return this.get(this.#keyList[i], getOptions);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from most
       * recently used to least recently used.
       *
       * `fn` is called as `fn(value, key, cache)`.
       *
       * If `thisp` is provided, function will be called in the `this`-context of
       * the provided object, or the cache if no `thisp` object is provided.
       *
       * Does not update age or recenty of use, or iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
          if (this.#isStale(i)) {
            this.#delete(this.#keyList[i], "expire");
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Returns `undefined` if the key is not present.
       *
       * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
       * serialization, the `start` value is always the current timestamp, and the
       * `ttl` is a calculated remaining time to live (negative if expired).
       *
       * Always returns stale values, if their info is found in the cache, so be
       * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
       * if relevant.
       */
      info(key) {
        const i = this.#keyMap.get(key);
        if (i === void 0)
          return void 0;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          return void 0;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          const ttl = this.#ttls[i];
          const start = this.#starts[i];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        return entry;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to {@link LRLUCache#load}.
       *
       * The `start` fields are calculated relative to a portable `Date.now()`
       * timestamp, even if `performance.now()` is available.
       *
       * Stale entries are always included in the `dump`, even if
       * {@link LRUCache.OptionsBase.allowStale} is false.
       *
       * Note: this returns an actual array, not a generator, so it can be more
       * easily passed around.
       */
      dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
          const key = this.#keyList[i];
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key === void 0)
            continue;
          const entry = { value };
          if (this.#ttls && this.#starts) {
            entry.ttl = this.#ttls[i];
            const age = perf.now() - this.#starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.#sizes) {
            entry.size = this.#sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       *
       * The shape of the resulting cache may be different if the same options are
       * not used in both caches.
       *
       * The `start` fields are assumed to be calculated relative to a portable
       * `Date.now()` timestamp, even if `performance.now()` is available.
       */
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       *
       * Fields on the {@link LRUCache.SetOptions} options param will override
       * their corresponding values in the constructor options for the scope
       * of this single `set()` operation.
       *
       * If `start` is provided, then that will set the effective start
       * time for the TTL calculation. Note that this must be a previous
       * value of `performance.now()` if supported, or a previous value of
       * `Date.now()` if not.
       *
       * Options object may also include `size`, which will prevent
       * calling the `sizeCalculation` function and just use the specified
       * number if it is a positive integer, and `noDisposeOnSet` which
       * will prevent calling a `dispose` function in the case of
       * overwrites.
       *
       * If the `size` (or return value of `sizeCalculation`) for a given
       * entry is greater than `maxEntrySize`, then the item will not be
       * added to the cache.
       *
       * Will update the recency of the entry.
       *
       * If the value is `undefined`, then this is an alias for
       * `cache.delete(key)`. `undefined` is never stored in the cache.
       */
      set(k, v, setOptions = {}) {
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.#delete(k, "set");
          return this;
        }
        let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
        if (index === void 0) {
          index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
          this.#keyList[index] = k;
          this.#valList[index] = v;
          this.#keyMap.set(k, index);
          this.#next[this.#tail] = index;
          this.#prev[index] = this.#tail;
          this.#tail = index;
          this.#size++;
          this.#addItemSize(index, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
        } else {
          this.#moveToTail(index);
          const oldVal = this.#valList[index];
          if (v !== oldVal) {
            if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if (this.#hasDispose) {
                  this.#dispose?.(s, k, "set");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(oldVal, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([oldVal, k, "set"]);
              }
            }
            this.#removeItemSize(index);
            this.#addItemSize(index, size, status);
            this.#valList[index] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && !this.#ttls) {
          this.#initializeTTLTracking();
        }
        if (this.#ttls) {
          if (!noUpdateTTL) {
            this.#setItemTTL(index, ttl, start);
          }
          if (status)
            this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        try {
          while (this.#size) {
            const val = this.#valList[this.#head];
            this.#evict(true);
            if (this.#isBackgroundFetch(val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while (task = dt?.shift()) {
              this.#disposeAfter?.(...task);
            }
          }
        }
      }
      #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("evicted"));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
          if (this.#hasDispose) {
            this.#dispose?.(v, k, "evict");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, "evict"]);
          }
        }
        this.#removeItemSize(head);
        if (free) {
          this.#keyList[head] = void 0;
          this.#valList[head] = void 0;
          this.#free.push(head);
        }
        if (this.#size === 1) {
          this.#head = this.#tail = 0;
          this.#free.length = 0;
        } else {
          this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Check if a key is in the cache, without updating the recency of
       * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
       * to `true` in either the options or the constructor.
       *
       * Will return `false` if the item is stale, even though it is technically in
       * the cache. The difference can be determined (if it matters) by using a
       * `status` argument, and inspecting the `has` field.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!this.#isStale(index)) {
            if (updateAgeOnHas) {
              this.#updateItemAge(index);
            }
            if (status) {
              status.has = "hit";
              this.#statusTTL(status, index);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            this.#statusTTL(status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === void 0 || !allowStale && this.#isStale(index)) {
          return;
        }
        const v = this.#valList[index];
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
      #backgroundFetch(k, index, options, context) {
        const v = index === void 0 ? void 0 : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const { signal } = options;
        signal?.addEventListener("abort", () => ac.abort(signal.reason), {
          signal: ac.signal
        });
        const fetchOpts = {
          signal: ac.signal,
          options,
          context
        };
        const cb = (v2, updateCache = false) => {
          const { aborted } = ac.signal;
          const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
          if (options.status) {
            if (aborted && !updateCache) {
              options.status.fetchAborted = true;
              options.status.fetchError = ac.signal.reason;
              if (ignoreAbort)
                options.status.fetchAbortIgnored = true;
            } else {
              options.status.fetchResolved = true;
            }
          }
          if (aborted && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          const bf2 = p;
          if (this.#valList[index] === p) {
            if (v2 === void 0) {
              if (bf2.__staleWhileFetching) {
                this.#valList[index] = bf2.__staleWhileFetching;
              } else {
                this.#delete(k, "fetch");
              }
            } else {
              if (options.status)
                options.status.fetchUpdated = true;
              this.set(k, v2, fetchOpts.options);
            }
          }
          return v2;
        };
        const eb = (er) => {
          if (options.status) {
            options.status.fetchRejected = true;
            options.status.fetchError = er;
          }
          return fetchFail(er);
        };
        const fetchFail = (er) => {
          const { aborted } = ac.signal;
          const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
          const noDelete = allowStale || options.noDeleteOnFetchRejection;
          const bf2 = p;
          if (this.#valList[index] === p) {
            const del = !noDelete || bf2.__staleWhileFetching === void 0;
            if (del) {
              this.#delete(k, "fetch");
            } else if (!allowStaleAborted) {
              this.#valList[index] = bf2.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options.status && bf2.__staleWhileFetching !== void 0) {
              options.status.returnedStale = true;
            }
            return bf2.__staleWhileFetching;
          } else if (bf2.__returned === bf2) {
            throw er;
          }
        };
        const pcall = (res, rej) => {
          const fmp = this.#fetchMethod?.(k, v, fetchOpts);
          if (fmp && fmp instanceof Promise) {
            fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
          }
          ac.signal.addEventListener("abort", () => {
            if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
              res(void 0);
              if (options.allowStaleOnFetchAbort) {
                res = (v2) => cb(v2, true);
              }
            }
          });
        };
        if (options.status)
          options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
          __abortController: ac,
          __staleWhileFetching: v,
          __returned: void 0
        });
        if (index === void 0) {
          this.set(k, bf, { ...fetchOpts.options, status: void 0 });
          index = this.#keyMap.get(k);
        } else {
          this.#valList[index] = bf;
        }
        return bf;
      }
      #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
          return false;
        const b = p;
        return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!this.#hasFetchMethod) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = this.#keyMap.get(k);
        if (index === void 0) {
          if (status)
            status.fetch = "miss";
          const p = this.#backgroundFetch(k, index, options, context);
          return p.__returned = p;
        } else {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = this.#isStale(index);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            if (status)
              this.#statusTTL(status, index);
            return v;
          }
          const p = this.#backgroundFetch(k, index, options, context);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === void 0)
          throw new Error("fetch() returned undefined");
        return v;
      }
      memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
          throw new Error("no memoMethod provided to constructor");
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== void 0)
          return v;
        const vv = memoMethod(k, v, {
          options,
          context
        });
        this.set(k, vv, options);
        return vv;
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const value = this.#valList[index];
          const fetching = this.#isBackgroundFetch(value);
          if (status)
            this.#statusTTL(status, index);
          if (this.#isStale(index)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.#delete(k, "expire");
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
      }
      #moveToTail(index) {
        if (index !== this.#tail) {
          if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            this.#connect(this.#prev[index], this.#next[index]);
          }
          this.#connect(this.#tail, index);
          this.#tail = index;
        }
      }
      /**
       * Deletes a key out of the cache.
       *
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k) {
        return this.#delete(k, "delete");
      }
      #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
          const index = this.#keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.#size === 1) {
              this.#clear(reason);
            } else {
              this.#removeItemSize(index);
              const v = this.#valList[index];
              if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
              } else if (this.#hasDispose || this.#hasDisposeAfter) {
                if (this.#hasDispose) {
                  this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([v, k, reason]);
                }
              }
              this.#keyMap.delete(k);
              this.#keyList[index] = void 0;
              this.#valList[index] = void 0;
              if (index === this.#tail) {
                this.#tail = this.#prev[index];
              } else if (index === this.#head) {
                this.#head = this.#next[index];
              } else {
                const pi = this.#prev[index];
                this.#next[pi] = this.#next[index];
                const ni = this.#next[index];
                this.#prev[ni] = this.#prev[index];
              }
              this.#size--;
              this.#free.push(index);
            }
          }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return deleted;
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        return this.#clear("delete");
      }
      #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.#keyList[index];
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
        }
        this.#keyMap.clear();
        this.#valList.fill(void 0);
        this.#keyList.fill(void 0);
        if (this.#ttls && this.#starts) {
          this.#ttls.fill(0);
          this.#starts.fill(0);
        }
        if (this.#sizes) {
          this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    };
    exports.LRUCache = LRUCache;
  }
});

// node_modules/js-sdsl/dist/esm/container/ContainerBase/index.js
var __extends, ContainerIterator, Base, Container;
var init_ContainerBase = __esm({
  "node_modules/js-sdsl/dist/esm/container/ContainerBase/index.js"() {
    __extends = /* @__PURE__ */ (function() {
      var extendStatics = function(n, t) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(n2, t2) {
          n2.__proto__ = t2;
        } || function(n2, t2) {
          for (var r in t2) if (Object.prototype.hasOwnProperty.call(t2, r)) n2[r] = t2[r];
        };
        return extendStatics(n, t);
      };
      return function(n, t) {
        if (typeof t !== "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        extendStatics(n, t);
        function __() {
          this.constructor = n;
        }
        n.prototype = t === null ? Object.create(t) : (__.prototype = t.prototype, new __());
      };
    })();
    ContainerIterator = (function() {
      function ContainerIterator2(n) {
        if (n === void 0) {
          n = 0;
        }
        this.iteratorType = n;
      }
      ContainerIterator2.prototype.equals = function(n) {
        return this.o === n.o;
      };
      return ContainerIterator2;
    })();
    Base = (function() {
      function Base2() {
        this.M = 0;
      }
      Object.defineProperty(Base2.prototype, "length", {
        get: function() {
          return this.M;
        },
        enumerable: false,
        configurable: true
      });
      Base2.prototype.size = function() {
        return this.M;
      };
      Base2.prototype.empty = function() {
        return this.M === 0;
      };
      return Base2;
    })();
    Container = (function(n) {
      __extends(Container2, n);
      function Container2() {
        return n !== null && n.apply(this, arguments) || this;
      }
      return Container2;
    })(Base);
  }
});

// node_modules/js-sdsl/dist/esm/container/OtherContainer/Stack.js
var __extends2, Stack, Stack_default;
var init_Stack = __esm({
  "node_modules/js-sdsl/dist/esm/container/OtherContainer/Stack.js"() {
    init_ContainerBase();
    __extends2 = /* @__PURE__ */ (function() {
      var extendStatics = function(t, n) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, n2) {
          t2.__proto__ = n2;
        } || function(t2, n2) {
          for (var i in n2) if (Object.prototype.hasOwnProperty.call(n2, i)) t2[i] = n2[i];
        };
        return extendStatics(t, n);
      };
      return function(t, n) {
        if (typeof n !== "function" && n !== null) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        extendStatics(t, n);
        function __() {
          this.constructor = t;
        }
        t.prototype = n === null ? Object.create(n) : (__.prototype = n.prototype, new __());
      };
    })();
    Stack = (function(t) {
      __extends2(Stack2, t);
      function Stack2(n) {
        if (n === void 0) {
          n = [];
        }
        var i = t.call(this) || this;
        i.nt = [];
        var r = i;
        n.forEach((function(t2) {
          r.push(t2);
        }));
        return i;
      }
      Stack2.prototype.clear = function() {
        this.M = 0;
        this.nt = [];
      };
      Stack2.prototype.push = function(t2) {
        this.nt.push(t2);
        this.M += 1;
        return this.M;
      };
      Stack2.prototype.pop = function() {
        if (this.M === 0) return;
        this.M -= 1;
        return this.nt.pop();
      };
      Stack2.prototype.top = function() {
        return this.nt[this.M - 1];
      };
      return Stack2;
    })(Base);
    Stack_default = Stack;
  }
});

// node_modules/js-sdsl/dist/esm/container/OtherContainer/Queue.js
var __extends3, Queue, Queue_default;
var init_Queue = __esm({
  "node_modules/js-sdsl/dist/esm/container/OtherContainer/Queue.js"() {
    init_ContainerBase();
    __extends3 = /* @__PURE__ */ (function() {
      var extendStatics = function(t, i) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, i2) {
          t2.__proto__ = i2;
        } || function(t2, i2) {
          for (var n in i2) if (Object.prototype.hasOwnProperty.call(i2, n)) t2[n] = i2[n];
        };
        return extendStatics(t, i);
      };
      return function(t, i) {
        if (typeof i !== "function" && i !== null) throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
        extendStatics(t, i);
        function __() {
          this.constructor = t;
        }
        t.prototype = i === null ? Object.create(i) : (__.prototype = i.prototype, new __());
      };
    })();
    Queue = (function(t) {
      __extends3(Queue2, t);
      function Queue2(i) {
        if (i === void 0) {
          i = [];
        }
        var n = t.call(this) || this;
        n.A = 0;
        n.tt = [];
        var e = n;
        i.forEach((function(t2) {
          e.push(t2);
        }));
        return n;
      }
      Queue2.prototype.clear = function() {
        this.tt = [];
        this.M = this.A = 0;
      };
      Queue2.prototype.push = function(t2) {
        var i = this.tt.length;
        if (this.A / i > 0.5 && this.A + this.M >= i && i > 4096) {
          var n = this.M;
          for (var e = 0; e < n; ++e) {
            this.tt[e] = this.tt[this.A + e];
          }
          this.A = 0;
          this.tt[this.M] = t2;
        } else this.tt[this.A + this.M] = t2;
        return ++this.M;
      };
      Queue2.prototype.pop = function() {
        if (this.M === 0) return;
        var t2 = this.tt[this.A++];
        this.M -= 1;
        return t2;
      };
      Queue2.prototype.front = function() {
        if (this.M === 0) return;
        return this.tt[this.A];
      };
      return Queue2;
    })(Base);
    Queue_default = Queue;
  }
});

// node_modules/js-sdsl/dist/esm/container/OtherContainer/PriorityQueue.js
var __extends4, __read, __spreadArray, PriorityQueue, PriorityQueue_default;
var init_PriorityQueue = __esm({
  "node_modules/js-sdsl/dist/esm/container/OtherContainer/PriorityQueue.js"() {
    init_ContainerBase();
    __extends4 = /* @__PURE__ */ (function() {
      var extendStatics = function(i, r) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(i2, r2) {
          i2.__proto__ = r2;
        } || function(i2, r2) {
          for (var t in r2) if (Object.prototype.hasOwnProperty.call(r2, t)) i2[t] = r2[t];
        };
        return extendStatics(i, r);
      };
      return function(i, r) {
        if (typeof r !== "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics(i, r);
        function __() {
          this.constructor = i;
        }
        i.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    })();
    __read = function(i, r) {
      var t = typeof Symbol === "function" && i[Symbol.iterator];
      if (!t) return i;
      var e = t.call(i), n, u = [], s;
      try {
        while ((r === void 0 || r-- > 0) && !(n = e.next()).done) u.push(n.value);
      } catch (i2) {
        s = {
          error: i2
        };
      } finally {
        try {
          if (n && !n.done && (t = e["return"])) t.call(e);
        } finally {
          if (s) throw s.error;
        }
      }
      return u;
    };
    __spreadArray = function(i, r, t) {
      if (t || arguments.length === 2) for (var e = 0, n = r.length, u; e < n; e++) {
        if (u || !(e in r)) {
          if (!u) u = Array.prototype.slice.call(r, 0, e);
          u[e] = r[e];
        }
      }
      return i.concat(u || Array.prototype.slice.call(r));
    };
    PriorityQueue = (function(i) {
      __extends4(PriorityQueue2, i);
      function PriorityQueue2(r, t, e) {
        if (r === void 0) {
          r = [];
        }
        if (t === void 0) {
          t = function(i2, r2) {
            if (i2 > r2) return -1;
            if (i2 < r2) return 1;
            return 0;
          };
        }
        if (e === void 0) {
          e = true;
        }
        var n = i.call(this) || this;
        n.$ = t;
        if (Array.isArray(r)) {
          n.ii = e ? __spreadArray([], __read(r), false) : r;
        } else {
          n.ii = [];
          var u = n;
          r.forEach((function(i2) {
            u.ii.push(i2);
          }));
        }
        n.M = n.ii.length;
        var s = n.M >> 1;
        for (var o = n.M - 1 >> 1; o >= 0; --o) {
          n.ri(o, s);
        }
        return n;
      }
      PriorityQueue2.prototype.ti = function(i2) {
        var r = this.ii[i2];
        while (i2 > 0) {
          var t = i2 - 1 >> 1;
          var e = this.ii[t];
          if (this.$(e, r) <= 0) break;
          this.ii[i2] = e;
          i2 = t;
        }
        this.ii[i2] = r;
      };
      PriorityQueue2.prototype.ri = function(i2, r) {
        var t = this.ii[i2];
        while (i2 < r) {
          var e = i2 << 1 | 1;
          var n = e + 1;
          var u = this.ii[e];
          if (n < this.M && this.$(u, this.ii[n]) > 0) {
            e = n;
            u = this.ii[n];
          }
          if (this.$(u, t) >= 0) break;
          this.ii[i2] = u;
          i2 = e;
        }
        this.ii[i2] = t;
      };
      PriorityQueue2.prototype.clear = function() {
        this.M = 0;
        this.ii.length = 0;
      };
      PriorityQueue2.prototype.push = function(i2) {
        this.ii.push(i2);
        this.ti(this.M);
        this.M += 1;
      };
      PriorityQueue2.prototype.pop = function() {
        if (this.M === 0) return;
        var i2 = this.ii[0];
        var r = this.ii.pop();
        this.M -= 1;
        if (this.M) {
          this.ii[0] = r;
          this.ri(0, this.M >> 1);
        }
        return i2;
      };
      PriorityQueue2.prototype.top = function() {
        return this.ii[0];
      };
      PriorityQueue2.prototype.find = function(i2) {
        return this.ii.indexOf(i2) >= 0;
      };
      PriorityQueue2.prototype.remove = function(i2) {
        var r = this.ii.indexOf(i2);
        if (r < 0) return false;
        if (r === 0) {
          this.pop();
        } else if (r === this.M - 1) {
          this.ii.pop();
          this.M -= 1;
        } else {
          this.ii.splice(r, 1, this.ii.pop());
          this.M -= 1;
          this.ti(r);
          this.ri(r, this.M >> 1);
        }
        return true;
      };
      PriorityQueue2.prototype.updateItem = function(i2) {
        var r = this.ii.indexOf(i2);
        if (r < 0) return false;
        this.ti(r);
        this.ri(r, this.M >> 1);
        return true;
      };
      PriorityQueue2.prototype.toArray = function() {
        return __spreadArray([], __read(this.ii), false);
      };
      return PriorityQueue2;
    })(Base);
    PriorityQueue_default = PriorityQueue;
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/Base/index.js
var __extends5, SequentialContainer, Base_default;
var init_Base = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/Base/index.js"() {
    init_ContainerBase();
    __extends5 = /* @__PURE__ */ (function() {
      var extendStatics = function(n, t) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(n2, t2) {
          n2.__proto__ = t2;
        } || function(n2, t2) {
          for (var e in t2) if (Object.prototype.hasOwnProperty.call(t2, e)) n2[e] = t2[e];
        };
        return extendStatics(n, t);
      };
      return function(n, t) {
        if (typeof t !== "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        extendStatics(n, t);
        function __() {
          this.constructor = n;
        }
        n.prototype = t === null ? Object.create(t) : (__.prototype = t.prototype, new __());
      };
    })();
    SequentialContainer = (function(n) {
      __extends5(SequentialContainer2, n);
      function SequentialContainer2() {
        return n !== null && n.apply(this, arguments) || this;
      }
      return SequentialContainer2;
    })(Container);
    Base_default = SequentialContainer;
  }
});

// node_modules/js-sdsl/dist/esm/utils/throwError.js
function throwIteratorAccessError() {
  throw new RangeError("Iterator access denied!");
}
var init_throwError = __esm({
  "node_modules/js-sdsl/dist/esm/utils/throwError.js"() {
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/Base/RandomIterator.js
var __extends6, RandomIterator;
var init_RandomIterator = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/Base/RandomIterator.js"() {
    init_ContainerBase();
    init_throwError();
    __extends6 = /* @__PURE__ */ (function() {
      var extendStatics = function(t, r) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, r2) {
          t2.__proto__ = r2;
        } || function(t2, r2) {
          for (var n in r2) if (Object.prototype.hasOwnProperty.call(r2, n)) t2[n] = r2[n];
        };
        return extendStatics(t, r);
      };
      return function(t, r) {
        if (typeof r !== "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics(t, r);
        function __() {
          this.constructor = t;
        }
        t.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    })();
    RandomIterator = (function(t) {
      __extends6(RandomIterator2, t);
      function RandomIterator2(r, n) {
        var o = t.call(this, n) || this;
        o.o = r;
        if (o.iteratorType === 0) {
          o.pre = function() {
            if (this.o === 0) {
              throwIteratorAccessError();
            }
            this.o -= 1;
            return this;
          };
          o.next = function() {
            if (this.o === this.container.size()) {
              throwIteratorAccessError();
            }
            this.o += 1;
            return this;
          };
        } else {
          o.pre = function() {
            if (this.o === this.container.size() - 1) {
              throwIteratorAccessError();
            }
            this.o += 1;
            return this;
          };
          o.next = function() {
            if (this.o === -1) {
              throwIteratorAccessError();
            }
            this.o -= 1;
            return this;
          };
        }
        return o;
      }
      Object.defineProperty(RandomIterator2.prototype, "pointer", {
        get: function() {
          return this.container.getElementByPos(this.o);
        },
        set: function(t2) {
          this.container.setElementByPos(this.o, t2);
        },
        enumerable: false,
        configurable: true
      });
      return RandomIterator2;
    })(ContainerIterator);
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/Vector.js
var __extends7, __generator, __read2, __spreadArray2, __values, VectorIterator, Vector, Vector_default;
var init_Vector = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/Vector.js"() {
    init_Base();
    init_RandomIterator();
    __extends7 = /* @__PURE__ */ (function() {
      var extendStatics = function(t, r) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, r2) {
          t2.__proto__ = r2;
        } || function(t2, r2) {
          for (var e in r2) if (Object.prototype.hasOwnProperty.call(r2, e)) t2[e] = r2[e];
        };
        return extendStatics(t, r);
      };
      return function(t, r) {
        if (typeof r !== "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics(t, r);
        function __() {
          this.constructor = t;
        }
        t.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    })();
    __generator = function(t, r) {
      var e = {
        label: 0,
        sent: function() {
          if (o[0] & 1) throw o[1];
          return o[1];
        },
        trys: [],
        ops: []
      }, n, i, o, u;
      return u = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (u[Symbol.iterator] = function() {
        return this;
      }), u;
      function verb(t2) {
        return function(r2) {
          return step([t2, r2]);
        };
      }
      function step(u2) {
        if (n) throw new TypeError("Generator is already executing.");
        while (e) try {
          if (n = 1, i && (o = u2[0] & 2 ? i["return"] : u2[0] ? i["throw"] || ((o = i["return"]) && o.call(i), 0) : i.next) && !(o = o.call(i, u2[1])).done) return o;
          if (i = 0, o) u2 = [u2[0] & 2, o.value];
          switch (u2[0]) {
            case 0:
            case 1:
              o = u2;
              break;
            case 4:
              e.label++;
              return {
                value: u2[1],
                done: false
              };
            case 5:
              e.label++;
              i = u2[1];
              u2 = [0];
              continue;
            case 7:
              u2 = e.ops.pop();
              e.trys.pop();
              continue;
            default:
              if (!(o = e.trys, o = o.length > 0 && o[o.length - 1]) && (u2[0] === 6 || u2[0] === 2)) {
                e = 0;
                continue;
              }
              if (u2[0] === 3 && (!o || u2[1] > o[0] && u2[1] < o[3])) {
                e.label = u2[1];
                break;
              }
              if (u2[0] === 6 && e.label < o[1]) {
                e.label = o[1];
                o = u2;
                break;
              }
              if (o && e.label < o[2]) {
                e.label = o[2];
                e.ops.push(u2);
                break;
              }
              if (o[2]) e.ops.pop();
              e.trys.pop();
              continue;
          }
          u2 = r.call(t, e);
        } catch (t2) {
          u2 = [6, t2];
          i = 0;
        } finally {
          n = o = 0;
        }
        if (u2[0] & 5) throw u2[1];
        return {
          value: u2[0] ? u2[1] : void 0,
          done: true
        };
      }
    };
    __read2 = function(t, r) {
      var e = typeof Symbol === "function" && t[Symbol.iterator];
      if (!e) return t;
      var n = e.call(t), i, o = [], u;
      try {
        while ((r === void 0 || r-- > 0) && !(i = n.next()).done) o.push(i.value);
      } catch (t2) {
        u = {
          error: t2
        };
      } finally {
        try {
          if (i && !i.done && (e = n["return"])) e.call(n);
        } finally {
          if (u) throw u.error;
        }
      }
      return o;
    };
    __spreadArray2 = function(t, r, e) {
      if (e || arguments.length === 2) for (var n = 0, i = r.length, o; n < i; n++) {
        if (o || !(n in r)) {
          if (!o) o = Array.prototype.slice.call(r, 0, n);
          o[n] = r[n];
        }
      }
      return t.concat(o || Array.prototype.slice.call(r));
    };
    __values = function(t) {
      var r = typeof Symbol === "function" && Symbol.iterator, e = r && t[r], n = 0;
      if (e) return e.call(t);
      if (t && typeof t.length === "number") return {
        next: function() {
          if (t && n >= t.length) t = void 0;
          return {
            value: t && t[n++],
            done: !t
          };
        }
      };
      throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    VectorIterator = (function(t) {
      __extends7(VectorIterator2, t);
      function VectorIterator2(r, e, n) {
        var i = t.call(this, r, n) || this;
        i.container = e;
        return i;
      }
      VectorIterator2.prototype.copy = function() {
        return new VectorIterator2(this.o, this.container, this.iteratorType);
      };
      return VectorIterator2;
    })(RandomIterator);
    Vector = (function(t) {
      __extends7(Vector2, t);
      function Vector2(r, e) {
        if (r === void 0) {
          r = [];
        }
        if (e === void 0) {
          e = true;
        }
        var n = t.call(this) || this;
        if (Array.isArray(r)) {
          n.J = e ? __spreadArray2([], __read2(r), false) : r;
          n.M = r.length;
        } else {
          n.J = [];
          var i = n;
          r.forEach((function(t2) {
            i.pushBack(t2);
          }));
        }
        return n;
      }
      Vector2.prototype.clear = function() {
        this.M = 0;
        this.J.length = 0;
      };
      Vector2.prototype.begin = function() {
        return new VectorIterator(0, this);
      };
      Vector2.prototype.end = function() {
        return new VectorIterator(this.M, this);
      };
      Vector2.prototype.rBegin = function() {
        return new VectorIterator(this.M - 1, this, 1);
      };
      Vector2.prototype.rEnd = function() {
        return new VectorIterator(-1, this, 1);
      };
      Vector2.prototype.front = function() {
        return this.J[0];
      };
      Vector2.prototype.back = function() {
        return this.J[this.M - 1];
      };
      Vector2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        return this.J[t2];
      };
      Vector2.prototype.eraseElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        this.J.splice(t2, 1);
        this.M -= 1;
        return this.M;
      };
      Vector2.prototype.eraseElementByValue = function(t2) {
        var r = 0;
        for (var e = 0; e < this.M; ++e) {
          if (this.J[e] !== t2) {
            this.J[r++] = this.J[e];
          }
        }
        this.M = this.J.length = r;
        return this.M;
      };
      Vector2.prototype.eraseElementByIterator = function(t2) {
        var r = t2.o;
        t2 = t2.next();
        this.eraseElementByPos(r);
        return t2;
      };
      Vector2.prototype.pushBack = function(t2) {
        this.J.push(t2);
        this.M += 1;
        return this.M;
      };
      Vector2.prototype.popBack = function() {
        if (this.M === 0) return;
        this.M -= 1;
        return this.J.pop();
      };
      Vector2.prototype.setElementByPos = function(t2, r) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        this.J[t2] = r;
      };
      Vector2.prototype.insert = function(t2, r, e) {
        var n;
        if (e === void 0) {
          e = 1;
        }
        if (t2 < 0 || t2 > this.M) {
          throw new RangeError();
        }
        (n = this.J).splice.apply(n, __spreadArray2([t2, 0], __read2(new Array(e).fill(r)), false));
        this.M += e;
        return this.M;
      };
      Vector2.prototype.find = function(t2) {
        for (var r = 0; r < this.M; ++r) {
          if (this.J[r] === t2) {
            return new VectorIterator(r, this);
          }
        }
        return this.end();
      };
      Vector2.prototype.reverse = function() {
        this.J.reverse();
      };
      Vector2.prototype.unique = function() {
        var t2 = 1;
        for (var r = 1; r < this.M; ++r) {
          if (this.J[r] !== this.J[r - 1]) {
            this.J[t2++] = this.J[r];
          }
        }
        this.M = this.J.length = t2;
        return this.M;
      };
      Vector2.prototype.sort = function(t2) {
        this.J.sort(t2);
      };
      Vector2.prototype.forEach = function(t2) {
        for (var r = 0; r < this.M; ++r) {
          t2(this.J[r], r, this);
        }
      };
      Vector2.prototype[Symbol.iterator] = function() {
        return (function() {
          return __generator(this, (function(t2) {
            switch (t2.label) {
              case 0:
                return [5, __values(this.J)];
              case 1:
                t2.sent();
                return [2];
            }
          }));
        }).bind(this)();
      };
      return Vector2;
    })(Base_default);
    Vector_default = Vector;
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/LinkList.js
var __extends8, __generator2, LinkListIterator, LinkList, LinkList_default;
var init_LinkList = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/LinkList.js"() {
    init_Base();
    init_ContainerBase();
    init_throwError();
    __extends8 = /* @__PURE__ */ (function() {
      var extendStatics = function(t, i) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, i2) {
          t2.__proto__ = i2;
        } || function(t2, i2) {
          for (var r in i2) if (Object.prototype.hasOwnProperty.call(i2, r)) t2[r] = i2[r];
        };
        return extendStatics(t, i);
      };
      return function(t, i) {
        if (typeof i !== "function" && i !== null) throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
        extendStatics(t, i);
        function __() {
          this.constructor = t;
        }
        t.prototype = i === null ? Object.create(i) : (__.prototype = i.prototype, new __());
      };
    })();
    __generator2 = function(t, i) {
      var r = {
        label: 0,
        sent: function() {
          if (e[0] & 1) throw e[1];
          return e[1];
        },
        trys: [],
        ops: []
      }, n, s, e, h;
      return h = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (h[Symbol.iterator] = function() {
        return this;
      }), h;
      function verb(t2) {
        return function(i2) {
          return step([t2, i2]);
        };
      }
      function step(h2) {
        if (n) throw new TypeError("Generator is already executing.");
        while (r) try {
          if (n = 1, s && (e = h2[0] & 2 ? s["return"] : h2[0] ? s["throw"] || ((e = s["return"]) && e.call(s), 0) : s.next) && !(e = e.call(s, h2[1])).done) return e;
          if (s = 0, e) h2 = [h2[0] & 2, e.value];
          switch (h2[0]) {
            case 0:
            case 1:
              e = h2;
              break;
            case 4:
              r.label++;
              return {
                value: h2[1],
                done: false
              };
            case 5:
              r.label++;
              s = h2[1];
              h2 = [0];
              continue;
            case 7:
              h2 = r.ops.pop();
              r.trys.pop();
              continue;
            default:
              if (!(e = r.trys, e = e.length > 0 && e[e.length - 1]) && (h2[0] === 6 || h2[0] === 2)) {
                r = 0;
                continue;
              }
              if (h2[0] === 3 && (!e || h2[1] > e[0] && h2[1] < e[3])) {
                r.label = h2[1];
                break;
              }
              if (h2[0] === 6 && r.label < e[1]) {
                r.label = e[1];
                e = h2;
                break;
              }
              if (e && r.label < e[2]) {
                r.label = e[2];
                r.ops.push(h2);
                break;
              }
              if (e[2]) r.ops.pop();
              r.trys.pop();
              continue;
          }
          h2 = i.call(t, r);
        } catch (t2) {
          h2 = [6, t2];
          s = 0;
        } finally {
          n = e = 0;
        }
        if (h2[0] & 5) throw h2[1];
        return {
          value: h2[0] ? h2[1] : void 0,
          done: true
        };
      }
    };
    LinkListIterator = (function(t) {
      __extends8(LinkListIterator2, t);
      function LinkListIterator2(i, r, n, s) {
        var e = t.call(this, s) || this;
        e.o = i;
        e.h = r;
        e.container = n;
        if (e.iteratorType === 0) {
          e.pre = function() {
            if (this.o.L === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L;
            return this;
          };
          e.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m;
            return this;
          };
        } else {
          e.pre = function() {
            if (this.o.m === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m;
            return this;
          };
          e.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L;
            return this;
          };
        }
        return e;
      }
      Object.defineProperty(LinkListIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          return this.o.p;
        },
        set: function(t2) {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          this.o.p = t2;
        },
        enumerable: false,
        configurable: true
      });
      LinkListIterator2.prototype.copy = function() {
        return new LinkListIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return LinkListIterator2;
    })(ContainerIterator);
    LinkList = (function(t) {
      __extends8(LinkList2, t);
      function LinkList2(i) {
        if (i === void 0) {
          i = [];
        }
        var r = t.call(this) || this;
        r.h = {};
        r.H = r.l = r.h.L = r.h.m = r.h;
        var n = r;
        i.forEach((function(t2) {
          n.pushBack(t2);
        }));
        return r;
      }
      LinkList2.prototype.G = function(t2) {
        var i = t2.L, r = t2.m;
        i.m = r;
        r.L = i;
        if (t2 === this.H) {
          this.H = r;
        }
        if (t2 === this.l) {
          this.l = i;
        }
        this.M -= 1;
      };
      LinkList2.prototype.F = function(t2, i) {
        var r = i.m;
        var n = {
          p: t2,
          L: i,
          m: r
        };
        i.m = n;
        r.L = n;
        if (i === this.h) {
          this.H = n;
        }
        if (r === this.h) {
          this.l = n;
        }
        this.M += 1;
      };
      LinkList2.prototype.clear = function() {
        this.M = 0;
        this.H = this.l = this.h.L = this.h.m = this.h;
      };
      LinkList2.prototype.begin = function() {
        return new LinkListIterator(this.H, this.h, this);
      };
      LinkList2.prototype.end = function() {
        return new LinkListIterator(this.h, this.h, this);
      };
      LinkList2.prototype.rBegin = function() {
        return new LinkListIterator(this.l, this.h, this, 1);
      };
      LinkList2.prototype.rEnd = function() {
        return new LinkListIterator(this.h, this.h, this, 1);
      };
      LinkList2.prototype.front = function() {
        return this.H.p;
      };
      LinkList2.prototype.back = function() {
        return this.l.p;
      };
      LinkList2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var i = this.H;
        while (t2--) {
          i = i.m;
        }
        return i.p;
      };
      LinkList2.prototype.eraseElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var i = this.H;
        while (t2--) {
          i = i.m;
        }
        this.G(i);
        return this.M;
      };
      LinkList2.prototype.eraseElementByValue = function(t2) {
        var i = this.H;
        while (i !== this.h) {
          if (i.p === t2) {
            this.G(i);
          }
          i = i.m;
        }
        return this.M;
      };
      LinkList2.prototype.eraseElementByIterator = function(t2) {
        var i = t2.o;
        if (i === this.h) {
          throwIteratorAccessError();
        }
        t2 = t2.next();
        this.G(i);
        return t2;
      };
      LinkList2.prototype.pushBack = function(t2) {
        this.F(t2, this.l);
        return this.M;
      };
      LinkList2.prototype.popBack = function() {
        if (this.M === 0) return;
        var t2 = this.l.p;
        this.G(this.l);
        return t2;
      };
      LinkList2.prototype.pushFront = function(t2) {
        this.F(t2, this.h);
        return this.M;
      };
      LinkList2.prototype.popFront = function() {
        if (this.M === 0) return;
        var t2 = this.H.p;
        this.G(this.H);
        return t2;
      };
      LinkList2.prototype.setElementByPos = function(t2, i) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var r = this.H;
        while (t2--) {
          r = r.m;
        }
        r.p = i;
      };
      LinkList2.prototype.insert = function(t2, i, r) {
        if (r === void 0) {
          r = 1;
        }
        if (t2 < 0 || t2 > this.M) {
          throw new RangeError();
        }
        if (r <= 0) return this.M;
        if (t2 === 0) {
          while (r--) this.pushFront(i);
        } else if (t2 === this.M) {
          while (r--) this.pushBack(i);
        } else {
          var n = this.H;
          for (var s = 1; s < t2; ++s) {
            n = n.m;
          }
          var e = n.m;
          this.M += r;
          while (r--) {
            n.m = {
              p: i,
              L: n
            };
            n.m.L = n;
            n = n.m;
          }
          n.m = e;
          e.L = n;
        }
        return this.M;
      };
      LinkList2.prototype.find = function(t2) {
        var i = this.H;
        while (i !== this.h) {
          if (i.p === t2) {
            return new LinkListIterator(i, this.h, this);
          }
          i = i.m;
        }
        return this.end();
      };
      LinkList2.prototype.reverse = function() {
        if (this.M <= 1) return;
        var t2 = this.H;
        var i = this.l;
        var r = 0;
        while (r << 1 < this.M) {
          var n = t2.p;
          t2.p = i.p;
          i.p = n;
          t2 = t2.m;
          i = i.L;
          r += 1;
        }
      };
      LinkList2.prototype.unique = function() {
        if (this.M <= 1) {
          return this.M;
        }
        var t2 = this.H;
        while (t2 !== this.h) {
          var i = t2;
          while (i.m !== this.h && i.p === i.m.p) {
            i = i.m;
            this.M -= 1;
          }
          t2.m = i.m;
          t2.m.L = t2;
          t2 = t2.m;
        }
        return this.M;
      };
      LinkList2.prototype.sort = function(t2) {
        if (this.M <= 1) return;
        var i = [];
        this.forEach((function(t3) {
          i.push(t3);
        }));
        i.sort(t2);
        var r = this.H;
        i.forEach((function(t3) {
          r.p = t3;
          r = r.m;
        }));
      };
      LinkList2.prototype.merge = function(t2) {
        var i = this;
        if (this.M === 0) {
          t2.forEach((function(t3) {
            i.pushBack(t3);
          }));
        } else {
          var r = this.H;
          t2.forEach((function(t3) {
            while (r !== i.h && r.p <= t3) {
              r = r.m;
            }
            i.F(t3, r.L);
          }));
        }
        return this.M;
      };
      LinkList2.prototype.forEach = function(t2) {
        var i = this.H;
        var r = 0;
        while (i !== this.h) {
          t2(i.p, r++, this);
          i = i.m;
        }
      };
      LinkList2.prototype[Symbol.iterator] = function() {
        return (function() {
          var t2;
          return __generator2(this, (function(i) {
            switch (i.label) {
              case 0:
                if (this.M === 0) return [2];
                t2 = this.H;
                i.label = 1;
              case 1:
                if (!(t2 !== this.h)) return [3, 3];
                return [4, t2.p];
              case 2:
                i.sent();
                t2 = t2.m;
                return [3, 1];
              case 3:
                return [2];
            }
          }));
        }).bind(this)();
      };
      return LinkList2;
    })(Base_default);
    LinkList_default = LinkList;
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/Deque.js
var __extends9, __generator3, __read3, __spreadArray3, DequeIterator, Deque, Deque_default;
var init_Deque = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/Deque.js"() {
    init_Base();
    init_RandomIterator();
    __extends9 = /* @__PURE__ */ (function() {
      var extendStatics = function(t, i) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, i2) {
          t2.__proto__ = i2;
        } || function(t2, i2) {
          for (var r in i2) if (Object.prototype.hasOwnProperty.call(i2, r)) t2[r] = i2[r];
        };
        return extendStatics(t, i);
      };
      return function(t, i) {
        if (typeof i !== "function" && i !== null) throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
        extendStatics(t, i);
        function __() {
          this.constructor = t;
        }
        t.prototype = i === null ? Object.create(i) : (__.prototype = i.prototype, new __());
      };
    })();
    __generator3 = function(t, i) {
      var r = {
        label: 0,
        sent: function() {
          if (h[0] & 1) throw h[1];
          return h[1];
        },
        trys: [],
        ops: []
      }, e, s, h, n;
      return n = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (n[Symbol.iterator] = function() {
        return this;
      }), n;
      function verb(t2) {
        return function(i2) {
          return step([t2, i2]);
        };
      }
      function step(n2) {
        if (e) throw new TypeError("Generator is already executing.");
        while (r) try {
          if (e = 1, s && (h = n2[0] & 2 ? s["return"] : n2[0] ? s["throw"] || ((h = s["return"]) && h.call(s), 0) : s.next) && !(h = h.call(s, n2[1])).done) return h;
          if (s = 0, h) n2 = [n2[0] & 2, h.value];
          switch (n2[0]) {
            case 0:
            case 1:
              h = n2;
              break;
            case 4:
              r.label++;
              return {
                value: n2[1],
                done: false
              };
            case 5:
              r.label++;
              s = n2[1];
              n2 = [0];
              continue;
            case 7:
              n2 = r.ops.pop();
              r.trys.pop();
              continue;
            default:
              if (!(h = r.trys, h = h.length > 0 && h[h.length - 1]) && (n2[0] === 6 || n2[0] === 2)) {
                r = 0;
                continue;
              }
              if (n2[0] === 3 && (!h || n2[1] > h[0] && n2[1] < h[3])) {
                r.label = n2[1];
                break;
              }
              if (n2[0] === 6 && r.label < h[1]) {
                r.label = h[1];
                h = n2;
                break;
              }
              if (h && r.label < h[2]) {
                r.label = h[2];
                r.ops.push(n2);
                break;
              }
              if (h[2]) r.ops.pop();
              r.trys.pop();
              continue;
          }
          n2 = i.call(t, r);
        } catch (t2) {
          n2 = [6, t2];
          s = 0;
        } finally {
          e = h = 0;
        }
        if (n2[0] & 5) throw n2[1];
        return {
          value: n2[0] ? n2[1] : void 0,
          done: true
        };
      }
    };
    __read3 = function(t, i) {
      var r = typeof Symbol === "function" && t[Symbol.iterator];
      if (!r) return t;
      var e = r.call(t), s, h = [], n;
      try {
        while ((i === void 0 || i-- > 0) && !(s = e.next()).done) h.push(s.value);
      } catch (t2) {
        n = {
          error: t2
        };
      } finally {
        try {
          if (s && !s.done && (r = e["return"])) r.call(e);
        } finally {
          if (n) throw n.error;
        }
      }
      return h;
    };
    __spreadArray3 = function(t, i, r) {
      if (r || arguments.length === 2) for (var e = 0, s = i.length, h; e < s; e++) {
        if (h || !(e in i)) {
          if (!h) h = Array.prototype.slice.call(i, 0, e);
          h[e] = i[e];
        }
      }
      return t.concat(h || Array.prototype.slice.call(i));
    };
    DequeIterator = (function(t) {
      __extends9(DequeIterator2, t);
      function DequeIterator2(i, r, e) {
        var s = t.call(this, i, e) || this;
        s.container = r;
        return s;
      }
      DequeIterator2.prototype.copy = function() {
        return new DequeIterator2(this.o, this.container, this.iteratorType);
      };
      return DequeIterator2;
    })(RandomIterator);
    Deque = (function(t) {
      __extends9(Deque2, t);
      function Deque2(i, r) {
        if (i === void 0) {
          i = [];
        }
        if (r === void 0) {
          r = 1 << 12;
        }
        var e = t.call(this) || this;
        e.A = 0;
        e.S = 0;
        e.R = 0;
        e.k = 0;
        e.C = 0;
        e.j = [];
        var s = (function() {
          if (typeof i.length === "number") return i.length;
          if (typeof i.size === "number") return i.size;
          if (typeof i.size === "function") return i.size();
          throw new TypeError("Cannot get the length or size of the container");
        })();
        e.B = r;
        e.C = Math.max(Math.ceil(s / e.B), 1);
        for (var h = 0; h < e.C; ++h) {
          e.j.push(new Array(e.B));
        }
        var n = Math.ceil(s / e.B);
        e.A = e.R = (e.C >> 1) - (n >> 1);
        e.S = e.k = e.B - s % e.B >> 1;
        var u = e;
        i.forEach((function(t2) {
          u.pushBack(t2);
        }));
        return e;
      }
      Deque2.prototype.O = function() {
        var t2 = [];
        var i = Math.max(this.C >> 1, 1);
        for (var r = 0; r < i; ++r) {
          t2[r] = new Array(this.B);
        }
        for (var r = this.A; r < this.C; ++r) {
          t2[t2.length] = this.j[r];
        }
        for (var r = 0; r < this.R; ++r) {
          t2[t2.length] = this.j[r];
        }
        t2[t2.length] = __spreadArray3([], __read3(this.j[this.R]), false);
        this.A = i;
        this.R = t2.length - 1;
        for (var r = 0; r < i; ++r) {
          t2[t2.length] = new Array(this.B);
        }
        this.j = t2;
        this.C = t2.length;
      };
      Deque2.prototype.T = function(t2) {
        var i = this.S + t2 + 1;
        var r = i % this.B;
        var e = r - 1;
        var s = this.A + (i - r) / this.B;
        if (r === 0) s -= 1;
        s %= this.C;
        if (e < 0) e += this.B;
        return {
          curNodeBucketIndex: s,
          curNodePointerIndex: e
        };
      };
      Deque2.prototype.clear = function() {
        this.j = [new Array(this.B)];
        this.C = 1;
        this.A = this.R = this.M = 0;
        this.S = this.k = this.B >> 1;
      };
      Deque2.prototype.begin = function() {
        return new DequeIterator(0, this);
      };
      Deque2.prototype.end = function() {
        return new DequeIterator(this.M, this);
      };
      Deque2.prototype.rBegin = function() {
        return new DequeIterator(this.M - 1, this, 1);
      };
      Deque2.prototype.rEnd = function() {
        return new DequeIterator(-1, this, 1);
      };
      Deque2.prototype.front = function() {
        if (this.M === 0) return;
        return this.j[this.A][this.S];
      };
      Deque2.prototype.back = function() {
        if (this.M === 0) return;
        return this.j[this.R][this.k];
      };
      Deque2.prototype.pushBack = function(t2) {
        if (this.M) {
          if (this.k < this.B - 1) {
            this.k += 1;
          } else if (this.R < this.C - 1) {
            this.R += 1;
            this.k = 0;
          } else {
            this.R = 0;
            this.k = 0;
          }
          if (this.R === this.A && this.k === this.S) this.O();
        }
        this.M += 1;
        this.j[this.R][this.k] = t2;
        return this.M;
      };
      Deque2.prototype.popBack = function() {
        if (this.M === 0) return;
        var t2 = this.j[this.R][this.k];
        if (this.M !== 1) {
          if (this.k > 0) {
            this.k -= 1;
          } else if (this.R > 0) {
            this.R -= 1;
            this.k = this.B - 1;
          } else {
            this.R = this.C - 1;
            this.k = this.B - 1;
          }
        }
        this.M -= 1;
        return t2;
      };
      Deque2.prototype.pushFront = function(t2) {
        if (this.M) {
          if (this.S > 0) {
            this.S -= 1;
          } else if (this.A > 0) {
            this.A -= 1;
            this.S = this.B - 1;
          } else {
            this.A = this.C - 1;
            this.S = this.B - 1;
          }
          if (this.A === this.R && this.S === this.k) this.O();
        }
        this.M += 1;
        this.j[this.A][this.S] = t2;
        return this.M;
      };
      Deque2.prototype.popFront = function() {
        if (this.M === 0) return;
        var t2 = this.j[this.A][this.S];
        if (this.M !== 1) {
          if (this.S < this.B - 1) {
            this.S += 1;
          } else if (this.A < this.C - 1) {
            this.A += 1;
            this.S = 0;
          } else {
            this.A = 0;
            this.S = 0;
          }
        }
        this.M -= 1;
        return t2;
      };
      Deque2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var i = this.T(t2), r = i.curNodeBucketIndex, e = i.curNodePointerIndex;
        return this.j[r][e];
      };
      Deque2.prototype.setElementByPos = function(t2, i) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var r = this.T(t2), e = r.curNodeBucketIndex, s = r.curNodePointerIndex;
        this.j[e][s] = i;
      };
      Deque2.prototype.insert = function(t2, i, r) {
        if (r === void 0) {
          r = 1;
        }
        if (t2 < 0 || t2 > this.M) {
          throw new RangeError();
        }
        if (t2 === 0) {
          while (r--) this.pushFront(i);
        } else if (t2 === this.M) {
          while (r--) this.pushBack(i);
        } else {
          var e = [];
          for (var s = t2; s < this.M; ++s) {
            e.push(this.getElementByPos(s));
          }
          this.cut(t2 - 1);
          for (var s = 0; s < r; ++s) this.pushBack(i);
          for (var s = 0; s < e.length; ++s) this.pushBack(e[s]);
        }
        return this.M;
      };
      Deque2.prototype.cut = function(t2) {
        if (t2 < 0) {
          this.clear();
          return 0;
        }
        var i = this.T(t2), r = i.curNodeBucketIndex, e = i.curNodePointerIndex;
        this.R = r;
        this.k = e;
        this.M = t2 + 1;
        return this.M;
      };
      Deque2.prototype.eraseElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        if (t2 === 0) this.popFront();
        else if (t2 === this.M - 1) this.popBack();
        else {
          var i = [];
          for (var r = t2 + 1; r < this.M; ++r) {
            i.push(this.getElementByPos(r));
          }
          this.cut(t2);
          this.popBack();
          var e = this;
          i.forEach((function(t3) {
            e.pushBack(t3);
          }));
        }
        return this.M;
      };
      Deque2.prototype.eraseElementByValue = function(t2) {
        if (this.M === 0) return 0;
        var i = [];
        for (var r = 0; r < this.M; ++r) {
          var e = this.getElementByPos(r);
          if (e !== t2) i.push(e);
        }
        var s = i.length;
        for (var r = 0; r < s; ++r) this.setElementByPos(r, i[r]);
        return this.cut(s - 1);
      };
      Deque2.prototype.eraseElementByIterator = function(t2) {
        var i = t2.o;
        this.eraseElementByPos(i);
        t2 = t2.next();
        return t2;
      };
      Deque2.prototype.find = function(t2) {
        for (var i = 0; i < this.M; ++i) {
          if (this.getElementByPos(i) === t2) {
            return new DequeIterator(i, this);
          }
        }
        return this.end();
      };
      Deque2.prototype.reverse = function() {
        var t2 = 0;
        var i = this.M - 1;
        while (t2 < i) {
          var r = this.getElementByPos(t2);
          this.setElementByPos(t2, this.getElementByPos(i));
          this.setElementByPos(i, r);
          t2 += 1;
          i -= 1;
        }
      };
      Deque2.prototype.unique = function() {
        if (this.M <= 1) {
          return this.M;
        }
        var t2 = 1;
        var i = this.getElementByPos(0);
        for (var r = 1; r < this.M; ++r) {
          var e = this.getElementByPos(r);
          if (e !== i) {
            i = e;
            this.setElementByPos(t2++, e);
          }
        }
        while (this.M > t2) this.popBack();
        return this.M;
      };
      Deque2.prototype.sort = function(t2) {
        var i = [];
        for (var r = 0; r < this.M; ++r) {
          i.push(this.getElementByPos(r));
        }
        i.sort(t2);
        for (var r = 0; r < this.M; ++r) this.setElementByPos(r, i[r]);
      };
      Deque2.prototype.shrinkToFit = function() {
        if (this.M === 0) return;
        var t2 = [];
        this.forEach((function(i2) {
          t2.push(i2);
        }));
        this.C = Math.max(Math.ceil(this.M / this.B), 1);
        this.M = this.A = this.R = this.S = this.k = 0;
        this.j = [];
        for (var i = 0; i < this.C; ++i) {
          this.j.push(new Array(this.B));
        }
        for (var i = 0; i < t2.length; ++i) this.pushBack(t2[i]);
      };
      Deque2.prototype.forEach = function(t2) {
        for (var i = 0; i < this.M; ++i) {
          t2(this.getElementByPos(i), i, this);
        }
      };
      Deque2.prototype[Symbol.iterator] = function() {
        return (function() {
          var t2;
          return __generator3(this, (function(i) {
            switch (i.label) {
              case 0:
                t2 = 0;
                i.label = 1;
              case 1:
                if (!(t2 < this.M)) return [3, 4];
                return [4, this.getElementByPos(t2)];
              case 2:
                i.sent();
                i.label = 3;
              case 3:
                ++t2;
                return [3, 1];
              case 4:
                return [2];
            }
          }));
        }).bind(this)();
      };
      return Deque2;
    })(Base_default);
    Deque_default = Deque;
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/TreeNode.js
var __extends10, TreeNode, TreeNodeEnableIndex;
var init_TreeNode = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/TreeNode.js"() {
    __extends10 = /* @__PURE__ */ (function() {
      var extendStatics = function(e, n) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(e2, n2) {
          e2.__proto__ = n2;
        } || function(e2, n2) {
          for (var t in n2) if (Object.prototype.hasOwnProperty.call(n2, t)) e2[t] = n2[t];
        };
        return extendStatics(e, n);
      };
      return function(e, n) {
        if (typeof n !== "function" && n !== null) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        extendStatics(e, n);
        function __() {
          this.constructor = e;
        }
        e.prototype = n === null ? Object.create(n) : (__.prototype = n.prototype, new __());
      };
    })();
    TreeNode = (function() {
      function TreeNode2(e, n) {
        this.ee = 1;
        this.u = void 0;
        this.p = void 0;
        this.K = void 0;
        this.N = void 0;
        this.rr = void 0;
        this.u = e;
        this.p = n;
      }
      TreeNode2.prototype.L = function() {
        var e = this;
        if (e.ee === 1 && e.rr.rr === e) {
          e = e.N;
        } else if (e.K) {
          e = e.K;
          while (e.N) {
            e = e.N;
          }
        } else {
          var n = e.rr;
          while (n.K === e) {
            e = n;
            n = e.rr;
          }
          e = n;
        }
        return e;
      };
      TreeNode2.prototype.m = function() {
        var e = this;
        if (e.N) {
          e = e.N;
          while (e.K) {
            e = e.K;
          }
          return e;
        } else {
          var n = e.rr;
          while (n.N === e) {
            e = n;
            n = e.rr;
          }
          if (e.N !== n) {
            return n;
          } else return e;
        }
      };
      TreeNode2.prototype.ne = function() {
        var e = this.rr;
        var n = this.N;
        var t = n.K;
        if (e.rr === this) e.rr = n;
        else if (e.K === this) e.K = n;
        else e.N = n;
        n.rr = e;
        n.K = this;
        this.rr = n;
        this.N = t;
        if (t) t.rr = this;
        return n;
      };
      TreeNode2.prototype.te = function() {
        var e = this.rr;
        var n = this.K;
        var t = n.N;
        if (e.rr === this) e.rr = n;
        else if (e.K === this) e.K = n;
        else e.N = n;
        n.rr = e;
        n.N = this;
        this.rr = n;
        this.K = t;
        if (t) t.rr = this;
        return n;
      };
      return TreeNode2;
    })();
    TreeNodeEnableIndex = (function(e) {
      __extends10(TreeNodeEnableIndex2, e);
      function TreeNodeEnableIndex2() {
        var n = e !== null && e.apply(this, arguments) || this;
        n.tr = 1;
        return n;
      }
      TreeNodeEnableIndex2.prototype.ne = function() {
        var n = e.prototype.ne.call(this);
        this.ie();
        n.ie();
        return n;
      };
      TreeNodeEnableIndex2.prototype.te = function() {
        var n = e.prototype.te.call(this);
        this.ie();
        n.ie();
        return n;
      };
      TreeNodeEnableIndex2.prototype.ie = function() {
        this.tr = 1;
        if (this.K) {
          this.tr += this.K.tr;
        }
        if (this.N) {
          this.tr += this.N.tr;
        }
      };
      return TreeNodeEnableIndex2;
    })(TreeNode);
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/index.js
var __extends11, __read4, __values2, TreeContainer, Base_default2;
var init_Base2 = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/index.js"() {
    init_TreeNode();
    init_ContainerBase();
    init_throwError();
    __extends11 = /* @__PURE__ */ (function() {
      var extendStatics = function(e, r) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(e2, r2) {
          e2.__proto__ = r2;
        } || function(e2, r2) {
          for (var i in r2) if (Object.prototype.hasOwnProperty.call(r2, i)) e2[i] = r2[i];
        };
        return extendStatics(e, r);
      };
      return function(e, r) {
        if (typeof r !== "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics(e, r);
        function __() {
          this.constructor = e;
        }
        e.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    })();
    __read4 = function(e, r) {
      var i = typeof Symbol === "function" && e[Symbol.iterator];
      if (!i) return e;
      var t = i.call(e), n, s = [], f;
      try {
        while ((r === void 0 || r-- > 0) && !(n = t.next()).done) s.push(n.value);
      } catch (e2) {
        f = {
          error: e2
        };
      } finally {
        try {
          if (n && !n.done && (i = t["return"])) i.call(t);
        } finally {
          if (f) throw f.error;
        }
      }
      return s;
    };
    __values2 = function(e) {
      var r = typeof Symbol === "function" && Symbol.iterator, i = r && e[r], t = 0;
      if (i) return i.call(e);
      if (e && typeof e.length === "number") return {
        next: function() {
          if (e && t >= e.length) e = void 0;
          return {
            value: e && e[t++],
            done: !e
          };
        }
      };
      throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    TreeContainer = (function(e) {
      __extends11(TreeContainer2, e);
      function TreeContainer2(r, i) {
        if (r === void 0) {
          r = function(e2, r2) {
            if (e2 < r2) return -1;
            if (e2 > r2) return 1;
            return 0;
          };
        }
        if (i === void 0) {
          i = false;
        }
        var t = e.call(this) || this;
        t.W = void 0;
        t.$ = r;
        if (i) {
          t.re = TreeNodeEnableIndex;
          t.v = function(e2, r2, i2) {
            var t2 = this.se(e2, r2, i2);
            if (t2) {
              var n = t2.rr;
              while (n !== this.h) {
                n.tr += 1;
                n = n.rr;
              }
              var s = this.fe(t2);
              if (s) {
                var f = s, h = f.parentNode, u = f.grandParent, a = f.curNode;
                h.ie();
                u.ie();
                a.ie();
              }
            }
            return this.M;
          };
          t.G = function(e2) {
            var r2 = this.he(e2);
            while (r2 !== this.h) {
              r2.tr -= 1;
              r2 = r2.rr;
            }
          };
        } else {
          t.re = TreeNode;
          t.v = function(e2, r2, i2) {
            var t2 = this.se(e2, r2, i2);
            if (t2) this.fe(t2);
            return this.M;
          };
          t.G = t.he;
        }
        t.h = new t.re();
        return t;
      }
      TreeContainer2.prototype.U = function(e2, r) {
        var i = this.h;
        while (e2) {
          var t = this.$(e2.u, r);
          if (t < 0) {
            e2 = e2.N;
          } else if (t > 0) {
            i = e2;
            e2 = e2.K;
          } else return e2;
        }
        return i;
      };
      TreeContainer2.prototype.X = function(e2, r) {
        var i = this.h;
        while (e2) {
          var t = this.$(e2.u, r);
          if (t <= 0) {
            e2 = e2.N;
          } else {
            i = e2;
            e2 = e2.K;
          }
        }
        return i;
      };
      TreeContainer2.prototype.Y = function(e2, r) {
        var i = this.h;
        while (e2) {
          var t = this.$(e2.u, r);
          if (t < 0) {
            i = e2;
            e2 = e2.N;
          } else if (t > 0) {
            e2 = e2.K;
          } else return e2;
        }
        return i;
      };
      TreeContainer2.prototype.Z = function(e2, r) {
        var i = this.h;
        while (e2) {
          var t = this.$(e2.u, r);
          if (t < 0) {
            i = e2;
            e2 = e2.N;
          } else {
            e2 = e2.K;
          }
        }
        return i;
      };
      TreeContainer2.prototype.ue = function(e2) {
        while (true) {
          var r = e2.rr;
          if (r === this.h) return;
          if (e2.ee === 1) {
            e2.ee = 0;
            return;
          }
          if (e2 === r.K) {
            var i = r.N;
            if (i.ee === 1) {
              i.ee = 0;
              r.ee = 1;
              if (r === this.W) {
                this.W = r.ne();
              } else r.ne();
            } else {
              if (i.N && i.N.ee === 1) {
                i.ee = r.ee;
                r.ee = 0;
                i.N.ee = 0;
                if (r === this.W) {
                  this.W = r.ne();
                } else r.ne();
                return;
              } else if (i.K && i.K.ee === 1) {
                i.ee = 1;
                i.K.ee = 0;
                i.te();
              } else {
                i.ee = 1;
                e2 = r;
              }
            }
          } else {
            var i = r.K;
            if (i.ee === 1) {
              i.ee = 0;
              r.ee = 1;
              if (r === this.W) {
                this.W = r.te();
              } else r.te();
            } else {
              if (i.K && i.K.ee === 1) {
                i.ee = r.ee;
                r.ee = 0;
                i.K.ee = 0;
                if (r === this.W) {
                  this.W = r.te();
                } else r.te();
                return;
              } else if (i.N && i.N.ee === 1) {
                i.ee = 1;
                i.N.ee = 0;
                i.ne();
              } else {
                i.ee = 1;
                e2 = r;
              }
            }
          }
        }
      };
      TreeContainer2.prototype.he = function(e2) {
        var r, i;
        if (this.M === 1) {
          this.clear();
          return this.h;
        }
        var t = e2;
        while (t.K || t.N) {
          if (t.N) {
            t = t.N;
            while (t.K) t = t.K;
          } else {
            t = t.K;
          }
          r = __read4([t.u, e2.u], 2), e2.u = r[0], t.u = r[1];
          i = __read4([t.p, e2.p], 2), e2.p = i[0], t.p = i[1];
          e2 = t;
        }
        if (this.h.K === t) {
          this.h.K = t.rr;
        } else if (this.h.N === t) {
          this.h.N = t.rr;
        }
        this.ue(t);
        var n = t.rr;
        if (t === n.K) {
          n.K = void 0;
        } else n.N = void 0;
        this.M -= 1;
        this.W.ee = 0;
        return n;
      };
      TreeContainer2.prototype.ae = function(e2, r) {
        if (e2 === void 0) return false;
        var i = this.ae(e2.K, r);
        if (i) return true;
        if (r(e2)) return true;
        return this.ae(e2.N, r);
      };
      TreeContainer2.prototype.fe = function(e2) {
        while (true) {
          var r = e2.rr;
          if (r.ee === 0) return;
          var i = r.rr;
          if (r === i.K) {
            var t = i.N;
            if (t && t.ee === 1) {
              t.ee = r.ee = 0;
              if (i === this.W) return;
              i.ee = 1;
              e2 = i;
              continue;
            } else if (e2 === r.N) {
              e2.ee = 0;
              if (e2.K) e2.K.rr = r;
              if (e2.N) e2.N.rr = i;
              r.N = e2.K;
              i.K = e2.N;
              e2.K = r;
              e2.N = i;
              if (i === this.W) {
                this.W = e2;
                this.h.rr = e2;
              } else {
                var n = i.rr;
                if (n.K === i) {
                  n.K = e2;
                } else n.N = e2;
              }
              e2.rr = i.rr;
              r.rr = e2;
              i.rr = e2;
              i.ee = 1;
              return {
                parentNode: r,
                grandParent: i,
                curNode: e2
              };
            } else {
              r.ee = 0;
              if (i === this.W) {
                this.W = i.te();
              } else i.te();
              i.ee = 1;
            }
          } else {
            var t = i.K;
            if (t && t.ee === 1) {
              t.ee = r.ee = 0;
              if (i === this.W) return;
              i.ee = 1;
              e2 = i;
              continue;
            } else if (e2 === r.K) {
              e2.ee = 0;
              if (e2.K) e2.K.rr = i;
              if (e2.N) e2.N.rr = r;
              i.N = e2.K;
              r.K = e2.N;
              e2.K = i;
              e2.N = r;
              if (i === this.W) {
                this.W = e2;
                this.h.rr = e2;
              } else {
                var n = i.rr;
                if (n.K === i) {
                  n.K = e2;
                } else n.N = e2;
              }
              e2.rr = i.rr;
              r.rr = e2;
              i.rr = e2;
              i.ee = 1;
              return {
                parentNode: r,
                grandParent: i,
                curNode: e2
              };
            } else {
              r.ee = 0;
              if (i === this.W) {
                this.W = i.ne();
              } else i.ne();
              i.ee = 1;
            }
          }
          return;
        }
      };
      TreeContainer2.prototype.se = function(e2, r, i) {
        if (this.W === void 0) {
          this.M += 1;
          this.W = new this.re(e2, r);
          this.W.ee = 0;
          this.W.rr = this.h;
          this.h.rr = this.W;
          this.h.K = this.W;
          this.h.N = this.W;
          return;
        }
        var t;
        var n = this.h.K;
        var s = this.$(n.u, e2);
        if (s === 0) {
          n.p = r;
          return;
        } else if (s > 0) {
          n.K = new this.re(e2, r);
          n.K.rr = n;
          t = n.K;
          this.h.K = t;
        } else {
          var f = this.h.N;
          var h = this.$(f.u, e2);
          if (h === 0) {
            f.p = r;
            return;
          } else if (h < 0) {
            f.N = new this.re(e2, r);
            f.N.rr = f;
            t = f.N;
            this.h.N = t;
          } else {
            if (i !== void 0) {
              var u = i.o;
              if (u !== this.h) {
                var a = this.$(u.u, e2);
                if (a === 0) {
                  u.p = r;
                  return;
                } else if (a > 0) {
                  var o = u.L();
                  var l = this.$(o.u, e2);
                  if (l === 0) {
                    o.p = r;
                    return;
                  } else if (l < 0) {
                    t = new this.re(e2, r);
                    if (o.N === void 0) {
                      o.N = t;
                      t.rr = o;
                    } else {
                      u.K = t;
                      t.rr = u;
                    }
                  }
                }
              }
            }
            if (t === void 0) {
              t = this.W;
              while (true) {
                var v = this.$(t.u, e2);
                if (v > 0) {
                  if (t.K === void 0) {
                    t.K = new this.re(e2, r);
                    t.K.rr = t;
                    t = t.K;
                    break;
                  }
                  t = t.K;
                } else if (v < 0) {
                  if (t.N === void 0) {
                    t.N = new this.re(e2, r);
                    t.N.rr = t;
                    t = t.N;
                    break;
                  }
                  t = t.N;
                } else {
                  t.p = r;
                  return;
                }
              }
            }
          }
        }
        this.M += 1;
        return t;
      };
      TreeContainer2.prototype.g = function(e2, r) {
        while (e2) {
          var i = this.$(e2.u, r);
          if (i < 0) {
            e2 = e2.N;
          } else if (i > 0) {
            e2 = e2.K;
          } else return e2;
        }
        return e2 || this.h;
      };
      TreeContainer2.prototype.clear = function() {
        this.M = 0;
        this.W = void 0;
        this.h.rr = void 0;
        this.h.K = this.h.N = void 0;
      };
      TreeContainer2.prototype.updateKeyByIterator = function(e2, r) {
        var i = e2.o;
        if (i === this.h) {
          throwIteratorAccessError();
        }
        if (this.M === 1) {
          i.u = r;
          return true;
        }
        if (i === this.h.K) {
          if (this.$(i.m().u, r) > 0) {
            i.u = r;
            return true;
          }
          return false;
        }
        if (i === this.h.N) {
          if (this.$(i.L().u, r) < 0) {
            i.u = r;
            return true;
          }
          return false;
        }
        var t = i.L().u;
        if (this.$(t, r) >= 0) return false;
        var n = i.m().u;
        if (this.$(n, r) <= 0) return false;
        i.u = r;
        return true;
      };
      TreeContainer2.prototype.eraseElementByPos = function(e2) {
        if (e2 < 0 || e2 > this.M - 1) {
          throw new RangeError();
        }
        var r = 0;
        var i = this;
        this.ae(this.W, (function(t) {
          if (e2 === r) {
            i.G(t);
            return true;
          }
          r += 1;
          return false;
        }));
        return this.M;
      };
      TreeContainer2.prototype.eraseElementByKey = function(e2) {
        if (this.M === 0) return false;
        var r = this.g(this.W, e2);
        if (r === this.h) return false;
        this.G(r);
        return true;
      };
      TreeContainer2.prototype.eraseElementByIterator = function(e2) {
        var r = e2.o;
        if (r === this.h) {
          throwIteratorAccessError();
        }
        var i = r.N === void 0;
        var t = e2.iteratorType === 0;
        if (t) {
          if (i) e2.next();
        } else {
          if (!i || r.K === void 0) e2.next();
        }
        this.G(r);
        return e2;
      };
      TreeContainer2.prototype.forEach = function(e2) {
        var r, i;
        var t = 0;
        try {
          for (var n = __values2(this), s = n.next(); !s.done; s = n.next()) {
            var f = s.value;
            e2(f, t++, this);
          }
        } catch (e3) {
          r = {
            error: e3
          };
        } finally {
          try {
            if (s && !s.done && (i = n.return)) i.call(n);
          } finally {
            if (r) throw r.error;
          }
        }
      };
      TreeContainer2.prototype.getElementByPos = function(e2) {
        var r, i;
        if (e2 < 0 || e2 > this.M - 1) {
          throw new RangeError();
        }
        var t;
        var n = 0;
        try {
          for (var s = __values2(this), f = s.next(); !f.done; f = s.next()) {
            var h = f.value;
            if (n === e2) {
              t = h;
              break;
            }
            n += 1;
          }
        } catch (e3) {
          r = {
            error: e3
          };
        } finally {
          try {
            if (f && !f.done && (i = s.return)) i.call(s);
          } finally {
            if (r) throw r.error;
          }
        }
        return t;
      };
      TreeContainer2.prototype.getHeight = function() {
        if (this.M === 0) return 0;
        var traversal = function(e2) {
          if (!e2) return 0;
          return Math.max(traversal(e2.K), traversal(e2.N)) + 1;
        };
        return traversal(this.W);
      };
      return TreeContainer2;
    })(Container);
    Base_default2 = TreeContainer;
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/TreeIterator.js
var __extends12, TreeIterator, TreeIterator_default;
var init_TreeIterator = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/TreeIterator.js"() {
    init_ContainerBase();
    init_throwError();
    __extends12 = /* @__PURE__ */ (function() {
      var extendStatics = function(r, t) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(r2, t2) {
          r2.__proto__ = t2;
        } || function(r2, t2) {
          for (var e in t2) if (Object.prototype.hasOwnProperty.call(t2, e)) r2[e] = t2[e];
        };
        return extendStatics(r, t);
      };
      return function(r, t) {
        if (typeof t !== "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        extendStatics(r, t);
        function __() {
          this.constructor = r;
        }
        r.prototype = t === null ? Object.create(t) : (__.prototype = t.prototype, new __());
      };
    })();
    TreeIterator = (function(r) {
      __extends12(TreeIterator2, r);
      function TreeIterator2(t, e, i) {
        var n = r.call(this, i) || this;
        n.o = t;
        n.h = e;
        if (n.iteratorType === 0) {
          n.pre = function() {
            if (this.o === this.h.K) {
              throwIteratorAccessError();
            }
            this.o = this.o.L();
            return this;
          };
          n.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m();
            return this;
          };
        } else {
          n.pre = function() {
            if (this.o === this.h.N) {
              throwIteratorAccessError();
            }
            this.o = this.o.m();
            return this;
          };
          n.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L();
            return this;
          };
        }
        return n;
      }
      Object.defineProperty(TreeIterator2.prototype, "index", {
        get: function() {
          var r2 = this.o;
          var t = this.h.rr;
          if (r2 === this.h) {
            if (t) {
              return t.tr - 1;
            }
            return 0;
          }
          var e = 0;
          if (r2.K) {
            e += r2.K.tr;
          }
          while (r2 !== t) {
            var i = r2.rr;
            if (r2 === i.N) {
              e += 1;
              if (i.K) {
                e += i.K.tr;
              }
            }
            r2 = i;
          }
          return e;
        },
        enumerable: false,
        configurable: true
      });
      return TreeIterator2;
    })(ContainerIterator);
    TreeIterator_default = TreeIterator;
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/OrderedSet.js
var __extends13, __generator4, __values3, OrderedSetIterator, OrderedSet, OrderedSet_default;
var init_OrderedSet = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/OrderedSet.js"() {
    init_Base2();
    init_TreeIterator();
    init_throwError();
    __extends13 = /* @__PURE__ */ (function() {
      var extendStatics = function(e, t) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(e2, t2) {
          e2.__proto__ = t2;
        } || function(e2, t2) {
          for (var r in t2) if (Object.prototype.hasOwnProperty.call(t2, r)) e2[r] = t2[r];
        };
        return extendStatics(e, t);
      };
      return function(e, t) {
        if (typeof t !== "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        extendStatics(e, t);
        function __() {
          this.constructor = e;
        }
        e.prototype = t === null ? Object.create(t) : (__.prototype = t.prototype, new __());
      };
    })();
    __generator4 = function(e, t) {
      var r = {
        label: 0,
        sent: function() {
          if (o[0] & 1) throw o[1];
          return o[1];
        },
        trys: [],
        ops: []
      }, n, i, o, u;
      return u = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (u[Symbol.iterator] = function() {
        return this;
      }), u;
      function verb(e2) {
        return function(t2) {
          return step([e2, t2]);
        };
      }
      function step(u2) {
        if (n) throw new TypeError("Generator is already executing.");
        while (r) try {
          if (n = 1, i && (o = u2[0] & 2 ? i["return"] : u2[0] ? i["throw"] || ((o = i["return"]) && o.call(i), 0) : i.next) && !(o = o.call(i, u2[1])).done) return o;
          if (i = 0, o) u2 = [u2[0] & 2, o.value];
          switch (u2[0]) {
            case 0:
            case 1:
              o = u2;
              break;
            case 4:
              r.label++;
              return {
                value: u2[1],
                done: false
              };
            case 5:
              r.label++;
              i = u2[1];
              u2 = [0];
              continue;
            case 7:
              u2 = r.ops.pop();
              r.trys.pop();
              continue;
            default:
              if (!(o = r.trys, o = o.length > 0 && o[o.length - 1]) && (u2[0] === 6 || u2[0] === 2)) {
                r = 0;
                continue;
              }
              if (u2[0] === 3 && (!o || u2[1] > o[0] && u2[1] < o[3])) {
                r.label = u2[1];
                break;
              }
              if (u2[0] === 6 && r.label < o[1]) {
                r.label = o[1];
                o = u2;
                break;
              }
              if (o && r.label < o[2]) {
                r.label = o[2];
                r.ops.push(u2);
                break;
              }
              if (o[2]) r.ops.pop();
              r.trys.pop();
              continue;
          }
          u2 = t.call(e, r);
        } catch (e2) {
          u2 = [6, e2];
          i = 0;
        } finally {
          n = o = 0;
        }
        if (u2[0] & 5) throw u2[1];
        return {
          value: u2[0] ? u2[1] : void 0,
          done: true
        };
      }
    };
    __values3 = function(e) {
      var t = typeof Symbol === "function" && Symbol.iterator, r = t && e[t], n = 0;
      if (r) return r.call(e);
      if (e && typeof e.length === "number") return {
        next: function() {
          if (e && n >= e.length) e = void 0;
          return {
            value: e && e[n++],
            done: !e
          };
        }
      };
      throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    OrderedSetIterator = (function(e) {
      __extends13(OrderedSetIterator2, e);
      function OrderedSetIterator2(t, r, n, i) {
        var o = e.call(this, t, r, i) || this;
        o.container = n;
        return o;
      }
      Object.defineProperty(OrderedSetIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          return this.o.u;
        },
        enumerable: false,
        configurable: true
      });
      OrderedSetIterator2.prototype.copy = function() {
        return new OrderedSetIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return OrderedSetIterator2;
    })(TreeIterator_default);
    OrderedSet = (function(e) {
      __extends13(OrderedSet2, e);
      function OrderedSet2(t, r, n) {
        if (t === void 0) {
          t = [];
        }
        var i = e.call(this, r, n) || this;
        var o = i;
        t.forEach((function(e2) {
          o.insert(e2);
        }));
        return i;
      }
      OrderedSet2.prototype.P = function(e2) {
        return __generator4(this, (function(t) {
          switch (t.label) {
            case 0:
              if (e2 === void 0) return [2];
              return [5, __values3(this.P(e2.K))];
            case 1:
              t.sent();
              return [4, e2.u];
            case 2:
              t.sent();
              return [5, __values3(this.P(e2.N))];
            case 3:
              t.sent();
              return [2];
          }
        }));
      };
      OrderedSet2.prototype.begin = function() {
        return new OrderedSetIterator(this.h.K || this.h, this.h, this);
      };
      OrderedSet2.prototype.end = function() {
        return new OrderedSetIterator(this.h, this.h, this);
      };
      OrderedSet2.prototype.rBegin = function() {
        return new OrderedSetIterator(this.h.N || this.h, this.h, this, 1);
      };
      OrderedSet2.prototype.rEnd = function() {
        return new OrderedSetIterator(this.h, this.h, this, 1);
      };
      OrderedSet2.prototype.front = function() {
        return this.h.K ? this.h.K.u : void 0;
      };
      OrderedSet2.prototype.back = function() {
        return this.h.N ? this.h.N.u : void 0;
      };
      OrderedSet2.prototype.insert = function(e2, t) {
        return this.v(e2, void 0, t);
      };
      OrderedSet2.prototype.find = function(e2) {
        var t = this.g(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.lowerBound = function(e2) {
        var t = this.U(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.upperBound = function(e2) {
        var t = this.X(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.reverseLowerBound = function(e2) {
        var t = this.Y(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.reverseUpperBound = function(e2) {
        var t = this.Z(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.union = function(e2) {
        var t = this;
        e2.forEach((function(e3) {
          t.insert(e3);
        }));
        return this.M;
      };
      OrderedSet2.prototype[Symbol.iterator] = function() {
        return this.P(this.W);
      };
      return OrderedSet2;
    })(Base_default2);
    OrderedSet_default = OrderedSet;
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/OrderedMap.js
var __extends14, __generator5, __values4, OrderedMapIterator, OrderedMap, OrderedMap_default;
var init_OrderedMap = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/OrderedMap.js"() {
    init_Base2();
    init_TreeIterator();
    init_throwError();
    __extends14 = /* @__PURE__ */ (function() {
      var extendStatics = function(r, e) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(r2, e2) {
          r2.__proto__ = e2;
        } || function(r2, e2) {
          for (var t in e2) if (Object.prototype.hasOwnProperty.call(e2, t)) r2[t] = e2[t];
        };
        return extendStatics(r, e);
      };
      return function(r, e) {
        if (typeof e !== "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
        extendStatics(r, e);
        function __() {
          this.constructor = r;
        }
        r.prototype = e === null ? Object.create(e) : (__.prototype = e.prototype, new __());
      };
    })();
    __generator5 = function(r, e) {
      var t = {
        label: 0,
        sent: function() {
          if (o[0] & 1) throw o[1];
          return o[1];
        },
        trys: [],
        ops: []
      }, n, i, o, a;
      return a = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (a[Symbol.iterator] = function() {
        return this;
      }), a;
      function verb(r2) {
        return function(e2) {
          return step([r2, e2]);
        };
      }
      function step(a2) {
        if (n) throw new TypeError("Generator is already executing.");
        while (t) try {
          if (n = 1, i && (o = a2[0] & 2 ? i["return"] : a2[0] ? i["throw"] || ((o = i["return"]) && o.call(i), 0) : i.next) && !(o = o.call(i, a2[1])).done) return o;
          if (i = 0, o) a2 = [a2[0] & 2, o.value];
          switch (a2[0]) {
            case 0:
            case 1:
              o = a2;
              break;
            case 4:
              t.label++;
              return {
                value: a2[1],
                done: false
              };
            case 5:
              t.label++;
              i = a2[1];
              a2 = [0];
              continue;
            case 7:
              a2 = t.ops.pop();
              t.trys.pop();
              continue;
            default:
              if (!(o = t.trys, o = o.length > 0 && o[o.length - 1]) && (a2[0] === 6 || a2[0] === 2)) {
                t = 0;
                continue;
              }
              if (a2[0] === 3 && (!o || a2[1] > o[0] && a2[1] < o[3])) {
                t.label = a2[1];
                break;
              }
              if (a2[0] === 6 && t.label < o[1]) {
                t.label = o[1];
                o = a2;
                break;
              }
              if (o && t.label < o[2]) {
                t.label = o[2];
                t.ops.push(a2);
                break;
              }
              if (o[2]) t.ops.pop();
              t.trys.pop();
              continue;
          }
          a2 = e.call(r, t);
        } catch (r2) {
          a2 = [6, r2];
          i = 0;
        } finally {
          n = o = 0;
        }
        if (a2[0] & 5) throw a2[1];
        return {
          value: a2[0] ? a2[1] : void 0,
          done: true
        };
      }
    };
    __values4 = function(r) {
      var e = typeof Symbol === "function" && Symbol.iterator, t = e && r[e], n = 0;
      if (t) return t.call(r);
      if (r && typeof r.length === "number") return {
        next: function() {
          if (r && n >= r.length) r = void 0;
          return {
            value: r && r[n++],
            done: !r
          };
        }
      };
      throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    OrderedMapIterator = (function(r) {
      __extends14(OrderedMapIterator2, r);
      function OrderedMapIterator2(e, t, n, i) {
        var o = r.call(this, e, t, i) || this;
        o.container = n;
        return o;
      }
      Object.defineProperty(OrderedMapIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          var r2 = this;
          return new Proxy([], {
            get: function(e, t) {
              if (t === "0") return r2.o.u;
              else if (t === "1") return r2.o.p;
            },
            set: function(e, t, n) {
              if (t !== "1") {
                throw new TypeError("props must be 1");
              }
              r2.o.p = n;
              return true;
            }
          });
        },
        enumerable: false,
        configurable: true
      });
      OrderedMapIterator2.prototype.copy = function() {
        return new OrderedMapIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return OrderedMapIterator2;
    })(TreeIterator_default);
    OrderedMap = (function(r) {
      __extends14(OrderedMap2, r);
      function OrderedMap2(e, t, n) {
        if (e === void 0) {
          e = [];
        }
        var i = r.call(this, t, n) || this;
        var o = i;
        e.forEach((function(r2) {
          o.setElement(r2[0], r2[1]);
        }));
        return i;
      }
      OrderedMap2.prototype.P = function(r2) {
        return __generator5(this, (function(e) {
          switch (e.label) {
            case 0:
              if (r2 === void 0) return [2];
              return [5, __values4(this.P(r2.K))];
            case 1:
              e.sent();
              return [4, [r2.u, r2.p]];
            case 2:
              e.sent();
              return [5, __values4(this.P(r2.N))];
            case 3:
              e.sent();
              return [2];
          }
        }));
      };
      OrderedMap2.prototype.begin = function() {
        return new OrderedMapIterator(this.h.K || this.h, this.h, this);
      };
      OrderedMap2.prototype.end = function() {
        return new OrderedMapIterator(this.h, this.h, this);
      };
      OrderedMap2.prototype.rBegin = function() {
        return new OrderedMapIterator(this.h.N || this.h, this.h, this, 1);
      };
      OrderedMap2.prototype.rEnd = function() {
        return new OrderedMapIterator(this.h, this.h, this, 1);
      };
      OrderedMap2.prototype.front = function() {
        if (this.M === 0) return;
        var r2 = this.h.K;
        return [r2.u, r2.p];
      };
      OrderedMap2.prototype.back = function() {
        if (this.M === 0) return;
        var r2 = this.h.N;
        return [r2.u, r2.p];
      };
      OrderedMap2.prototype.lowerBound = function(r2) {
        var e = this.U(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.upperBound = function(r2) {
        var e = this.X(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.reverseLowerBound = function(r2) {
        var e = this.Y(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.reverseUpperBound = function(r2) {
        var e = this.Z(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.setElement = function(r2, e, t) {
        return this.v(r2, e, t);
      };
      OrderedMap2.prototype.find = function(r2) {
        var e = this.g(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.getElementByKey = function(r2) {
        var e = this.g(this.W, r2);
        return e.p;
      };
      OrderedMap2.prototype.union = function(r2) {
        var e = this;
        r2.forEach((function(r3) {
          e.setElement(r3[0], r3[1]);
        }));
        return this.M;
      };
      OrderedMap2.prototype[Symbol.iterator] = function() {
        return this.P(this.W);
      };
      return OrderedMap2;
    })(Base_default2);
    OrderedMap_default = OrderedMap;
  }
});

// node_modules/js-sdsl/dist/esm/utils/checkObject.js
function checkObject(t) {
  var e = typeof t;
  return e === "object" && t !== null || e === "function";
}
var init_checkObject = __esm({
  "node_modules/js-sdsl/dist/esm/utils/checkObject.js"() {
  }
});

// node_modules/js-sdsl/dist/esm/container/HashContainer/Base/index.js
var __extends15, HashContainerIterator, HashContainer;
var init_Base3 = __esm({
  "node_modules/js-sdsl/dist/esm/container/HashContainer/Base/index.js"() {
    init_ContainerBase();
    init_checkObject();
    init_throwError();
    __extends15 = /* @__PURE__ */ (function() {
      var extendStatics = function(t, i) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, i2) {
          t2.__proto__ = i2;
        } || function(t2, i2) {
          for (var r in i2) if (Object.prototype.hasOwnProperty.call(i2, r)) t2[r] = i2[r];
        };
        return extendStatics(t, i);
      };
      return function(t, i) {
        if (typeof i !== "function" && i !== null) throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
        extendStatics(t, i);
        function __() {
          this.constructor = t;
        }
        t.prototype = i === null ? Object.create(i) : (__.prototype = i.prototype, new __());
      };
    })();
    HashContainerIterator = (function(t) {
      __extends15(HashContainerIterator2, t);
      function HashContainerIterator2(i, r, e) {
        var n = t.call(this, e) || this;
        n.o = i;
        n.h = r;
        if (n.iteratorType === 0) {
          n.pre = function() {
            if (this.o.L === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L;
            return this;
          };
          n.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m;
            return this;
          };
        } else {
          n.pre = function() {
            if (this.o.m === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m;
            return this;
          };
          n.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L;
            return this;
          };
        }
        return n;
      }
      return HashContainerIterator2;
    })(ContainerIterator);
    HashContainer = (function(t) {
      __extends15(HashContainer2, t);
      function HashContainer2() {
        var i = t.call(this) || this;
        i._ = [];
        i.I = {};
        i.HASH_TAG = Symbol("@@HASH_TAG");
        Object.setPrototypeOf(i.I, null);
        i.h = {};
        i.h.L = i.h.m = i.H = i.l = i.h;
        return i;
      }
      HashContainer2.prototype.G = function(t2) {
        var i = t2.L, r = t2.m;
        i.m = r;
        r.L = i;
        if (t2 === this.H) {
          this.H = r;
        }
        if (t2 === this.l) {
          this.l = i;
        }
        this.M -= 1;
      };
      HashContainer2.prototype.v = function(t2, i, r) {
        if (r === void 0) r = checkObject(t2);
        var e;
        if (r) {
          var n = t2[this.HASH_TAG];
          if (n !== void 0) {
            this._[n].p = i;
            return this.M;
          }
          Object.defineProperty(t2, this.HASH_TAG, {
            value: this._.length,
            configurable: true
          });
          e = {
            u: t2,
            p: i,
            L: this.l,
            m: this.h
          };
          this._.push(e);
        } else {
          var s = this.I[t2];
          if (s) {
            s.p = i;
            return this.M;
          }
          e = {
            u: t2,
            p: i,
            L: this.l,
            m: this.h
          };
          this.I[t2] = e;
        }
        if (this.M === 0) {
          this.H = e;
          this.h.m = e;
        } else {
          this.l.m = e;
        }
        this.l = e;
        this.h.L = e;
        return ++this.M;
      };
      HashContainer2.prototype.g = function(t2, i) {
        if (i === void 0) i = checkObject(t2);
        if (i) {
          var r = t2[this.HASH_TAG];
          if (r === void 0) return this.h;
          return this._[r];
        } else {
          return this.I[t2] || this.h;
        }
      };
      HashContainer2.prototype.clear = function() {
        var t2 = this.HASH_TAG;
        this._.forEach((function(i) {
          delete i.u[t2];
        }));
        this._ = [];
        this.I = {};
        Object.setPrototypeOf(this.I, null);
        this.M = 0;
        this.H = this.l = this.h.L = this.h.m = this.h;
      };
      HashContainer2.prototype.eraseElementByKey = function(t2, i) {
        var r;
        if (i === void 0) i = checkObject(t2);
        if (i) {
          var e = t2[this.HASH_TAG];
          if (e === void 0) return false;
          delete t2[this.HASH_TAG];
          r = this._[e];
          delete this._[e];
        } else {
          r = this.I[t2];
          if (r === void 0) return false;
          delete this.I[t2];
        }
        this.G(r);
        return true;
      };
      HashContainer2.prototype.eraseElementByIterator = function(t2) {
        var i = t2.o;
        if (i === this.h) {
          throwIteratorAccessError();
        }
        this.G(i);
        return t2.next();
      };
      HashContainer2.prototype.eraseElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var i = this.H;
        while (t2--) {
          i = i.m;
        }
        this.G(i);
        return this.M;
      };
      return HashContainer2;
    })(Container);
  }
});

// node_modules/js-sdsl/dist/esm/container/HashContainer/HashSet.js
var __extends16, __generator6, HashSetIterator, HashSet, HashSet_default;
var init_HashSet = __esm({
  "node_modules/js-sdsl/dist/esm/container/HashContainer/HashSet.js"() {
    init_Base3();
    init_throwError();
    __extends16 = /* @__PURE__ */ (function() {
      var extendStatics = function(t, r) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, r2) {
          t2.__proto__ = r2;
        } || function(t2, r2) {
          for (var e in r2) if (Object.prototype.hasOwnProperty.call(r2, e)) t2[e] = r2[e];
        };
        return extendStatics(t, r);
      };
      return function(t, r) {
        if (typeof r !== "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics(t, r);
        function __() {
          this.constructor = t;
        }
        t.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    })();
    __generator6 = function(t, r) {
      var e = {
        label: 0,
        sent: function() {
          if (s[0] & 1) throw s[1];
          return s[1];
        },
        trys: [],
        ops: []
      }, n, i, s, a;
      return a = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (a[Symbol.iterator] = function() {
        return this;
      }), a;
      function verb(t2) {
        return function(r2) {
          return step([t2, r2]);
        };
      }
      function step(a2) {
        if (n) throw new TypeError("Generator is already executing.");
        while (e) try {
          if (n = 1, i && (s = a2[0] & 2 ? i["return"] : a2[0] ? i["throw"] || ((s = i["return"]) && s.call(i), 0) : i.next) && !(s = s.call(i, a2[1])).done) return s;
          if (i = 0, s) a2 = [a2[0] & 2, s.value];
          switch (a2[0]) {
            case 0:
            case 1:
              s = a2;
              break;
            case 4:
              e.label++;
              return {
                value: a2[1],
                done: false
              };
            case 5:
              e.label++;
              i = a2[1];
              a2 = [0];
              continue;
            case 7:
              a2 = e.ops.pop();
              e.trys.pop();
              continue;
            default:
              if (!(s = e.trys, s = s.length > 0 && s[s.length - 1]) && (a2[0] === 6 || a2[0] === 2)) {
                e = 0;
                continue;
              }
              if (a2[0] === 3 && (!s || a2[1] > s[0] && a2[1] < s[3])) {
                e.label = a2[1];
                break;
              }
              if (a2[0] === 6 && e.label < s[1]) {
                e.label = s[1];
                s = a2;
                break;
              }
              if (s && e.label < s[2]) {
                e.label = s[2];
                e.ops.push(a2);
                break;
              }
              if (s[2]) e.ops.pop();
              e.trys.pop();
              continue;
          }
          a2 = r.call(t, e);
        } catch (t2) {
          a2 = [6, t2];
          i = 0;
        } finally {
          n = s = 0;
        }
        if (a2[0] & 5) throw a2[1];
        return {
          value: a2[0] ? a2[1] : void 0,
          done: true
        };
      }
    };
    HashSetIterator = (function(t) {
      __extends16(HashSetIterator2, t);
      function HashSetIterator2(r, e, n, i) {
        var s = t.call(this, r, e, i) || this;
        s.container = n;
        return s;
      }
      Object.defineProperty(HashSetIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          return this.o.u;
        },
        enumerable: false,
        configurable: true
      });
      HashSetIterator2.prototype.copy = function() {
        return new HashSetIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return HashSetIterator2;
    })(HashContainerIterator);
    HashSet = (function(t) {
      __extends16(HashSet2, t);
      function HashSet2(r) {
        if (r === void 0) {
          r = [];
        }
        var e = t.call(this) || this;
        var n = e;
        r.forEach((function(t2) {
          n.insert(t2);
        }));
        return e;
      }
      HashSet2.prototype.begin = function() {
        return new HashSetIterator(this.H, this.h, this);
      };
      HashSet2.prototype.end = function() {
        return new HashSetIterator(this.h, this.h, this);
      };
      HashSet2.prototype.rBegin = function() {
        return new HashSetIterator(this.l, this.h, this, 1);
      };
      HashSet2.prototype.rEnd = function() {
        return new HashSetIterator(this.h, this.h, this, 1);
      };
      HashSet2.prototype.front = function() {
        return this.H.u;
      };
      HashSet2.prototype.back = function() {
        return this.l.u;
      };
      HashSet2.prototype.insert = function(t2, r) {
        return this.v(t2, void 0, r);
      };
      HashSet2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var r = this.H;
        while (t2--) {
          r = r.m;
        }
        return r.u;
      };
      HashSet2.prototype.find = function(t2, r) {
        var e = this.g(t2, r);
        return new HashSetIterator(e, this.h, this);
      };
      HashSet2.prototype.forEach = function(t2) {
        var r = 0;
        var e = this.H;
        while (e !== this.h) {
          t2(e.u, r++, this);
          e = e.m;
        }
      };
      HashSet2.prototype[Symbol.iterator] = function() {
        return (function() {
          var t2;
          return __generator6(this, (function(r) {
            switch (r.label) {
              case 0:
                t2 = this.H;
                r.label = 1;
              case 1:
                if (!(t2 !== this.h)) return [3, 3];
                return [4, t2.u];
              case 2:
                r.sent();
                t2 = t2.m;
                return [3, 1];
              case 3:
                return [2];
            }
          }));
        }).bind(this)();
      };
      return HashSet2;
    })(HashContainer);
    HashSet_default = HashSet;
  }
});

// node_modules/js-sdsl/dist/esm/container/HashContainer/HashMap.js
var __extends17, __generator7, HashMapIterator, HashMap, HashMap_default;
var init_HashMap = __esm({
  "node_modules/js-sdsl/dist/esm/container/HashContainer/HashMap.js"() {
    init_Base3();
    init_checkObject();
    init_throwError();
    __extends17 = /* @__PURE__ */ (function() {
      var extendStatics = function(t, r) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, r2) {
          t2.__proto__ = r2;
        } || function(t2, r2) {
          for (var n in r2) if (Object.prototype.hasOwnProperty.call(r2, n)) t2[n] = r2[n];
        };
        return extendStatics(t, r);
      };
      return function(t, r) {
        if (typeof r !== "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics(t, r);
        function __() {
          this.constructor = t;
        }
        t.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    })();
    __generator7 = function(t, r) {
      var n = {
        label: 0,
        sent: function() {
          if (a[0] & 1) throw a[1];
          return a[1];
        },
        trys: [],
        ops: []
      }, e, i, a, s;
      return s = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (s[Symbol.iterator] = function() {
        return this;
      }), s;
      function verb(t2) {
        return function(r2) {
          return step([t2, r2]);
        };
      }
      function step(s2) {
        if (e) throw new TypeError("Generator is already executing.");
        while (n) try {
          if (e = 1, i && (a = s2[0] & 2 ? i["return"] : s2[0] ? i["throw"] || ((a = i["return"]) && a.call(i), 0) : i.next) && !(a = a.call(i, s2[1])).done) return a;
          if (i = 0, a) s2 = [s2[0] & 2, a.value];
          switch (s2[0]) {
            case 0:
            case 1:
              a = s2;
              break;
            case 4:
              n.label++;
              return {
                value: s2[1],
                done: false
              };
            case 5:
              n.label++;
              i = s2[1];
              s2 = [0];
              continue;
            case 7:
              s2 = n.ops.pop();
              n.trys.pop();
              continue;
            default:
              if (!(a = n.trys, a = a.length > 0 && a[a.length - 1]) && (s2[0] === 6 || s2[0] === 2)) {
                n = 0;
                continue;
              }
              if (s2[0] === 3 && (!a || s2[1] > a[0] && s2[1] < a[3])) {
                n.label = s2[1];
                break;
              }
              if (s2[0] === 6 && n.label < a[1]) {
                n.label = a[1];
                a = s2;
                break;
              }
              if (a && n.label < a[2]) {
                n.label = a[2];
                n.ops.push(s2);
                break;
              }
              if (a[2]) n.ops.pop();
              n.trys.pop();
              continue;
          }
          s2 = r.call(t, n);
        } catch (t2) {
          s2 = [6, t2];
          i = 0;
        } finally {
          e = a = 0;
        }
        if (s2[0] & 5) throw s2[1];
        return {
          value: s2[0] ? s2[1] : void 0,
          done: true
        };
      }
    };
    HashMapIterator = (function(t) {
      __extends17(HashMapIterator2, t);
      function HashMapIterator2(r, n, e, i) {
        var a = t.call(this, r, n, i) || this;
        a.container = e;
        return a;
      }
      Object.defineProperty(HashMapIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          var t2 = this;
          return new Proxy([], {
            get: function(r, n) {
              if (n === "0") return t2.o.u;
              else if (n === "1") return t2.o.p;
            },
            set: function(r, n, e) {
              if (n !== "1") {
                throw new TypeError("props must be 1");
              }
              t2.o.p = e;
              return true;
            }
          });
        },
        enumerable: false,
        configurable: true
      });
      HashMapIterator2.prototype.copy = function() {
        return new HashMapIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return HashMapIterator2;
    })(HashContainerIterator);
    HashMap = (function(t) {
      __extends17(HashMap2, t);
      function HashMap2(r) {
        if (r === void 0) {
          r = [];
        }
        var n = t.call(this) || this;
        var e = n;
        r.forEach((function(t2) {
          e.setElement(t2[0], t2[1]);
        }));
        return n;
      }
      HashMap2.prototype.begin = function() {
        return new HashMapIterator(this.H, this.h, this);
      };
      HashMap2.prototype.end = function() {
        return new HashMapIterator(this.h, this.h, this);
      };
      HashMap2.prototype.rBegin = function() {
        return new HashMapIterator(this.l, this.h, this, 1);
      };
      HashMap2.prototype.rEnd = function() {
        return new HashMapIterator(this.h, this.h, this, 1);
      };
      HashMap2.prototype.front = function() {
        if (this.M === 0) return;
        return [this.H.u, this.H.p];
      };
      HashMap2.prototype.back = function() {
        if (this.M === 0) return;
        return [this.l.u, this.l.p];
      };
      HashMap2.prototype.setElement = function(t2, r, n) {
        return this.v(t2, r, n);
      };
      HashMap2.prototype.getElementByKey = function(t2, r) {
        if (r === void 0) r = checkObject(t2);
        if (r) {
          var n = t2[this.HASH_TAG];
          return n !== void 0 ? this._[n].p : void 0;
        }
        var e = this.I[t2];
        return e ? e.p : void 0;
      };
      HashMap2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var r = this.H;
        while (t2--) {
          r = r.m;
        }
        return [r.u, r.p];
      };
      HashMap2.prototype.find = function(t2, r) {
        var n = this.g(t2, r);
        return new HashMapIterator(n, this.h, this);
      };
      HashMap2.prototype.forEach = function(t2) {
        var r = 0;
        var n = this.H;
        while (n !== this.h) {
          t2([n.u, n.p], r++, this);
          n = n.m;
        }
      };
      HashMap2.prototype[Symbol.iterator] = function() {
        return (function() {
          var t2;
          return __generator7(this, (function(r) {
            switch (r.label) {
              case 0:
                t2 = this.H;
                r.label = 1;
              case 1:
                if (!(t2 !== this.h)) return [3, 3];
                return [4, [t2.u, t2.p]];
              case 2:
                r.sent();
                t2 = t2.m;
                return [3, 1];
              case 3:
                return [2];
            }
          }));
        }).bind(this)();
      };
      return HashMap2;
    })(HashContainer);
    HashMap_default = HashMap;
  }
});

// node_modules/js-sdsl/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Deque: () => Deque_default,
  HashMap: () => HashMap_default,
  HashSet: () => HashSet_default,
  LinkList: () => LinkList_default,
  OrderedMap: () => OrderedMap_default,
  OrderedSet: () => OrderedSet_default,
  PriorityQueue: () => PriorityQueue_default,
  Queue: () => Queue_default,
  Stack: () => Stack_default,
  Vector: () => Vector_default
});
var init_esm = __esm({
  "node_modules/js-sdsl/dist/esm/index.js"() {
    init_Stack();
    init_Queue();
    init_PriorityQueue();
    init_Vector();
    init_LinkList();
    init_Deque();
    init_OrderedSet();
    init_OrderedMap();
    init_HashSet();
    init_HashMap();
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/number-allocator/lib/number-allocator.js
var require_number_allocator = __commonJS({
  "node_modules/number-allocator/lib/number-allocator.js"(exports, module) {
    "use strict";
    var SortedSet = (init_esm(), __toCommonJS(esm_exports)).OrderedSet;
    var debugTrace = require_browser()("number-allocator:trace");
    var debugError = require_browser()("number-allocator:error");
    function Interval(low, high) {
      this.low = low;
      this.high = high;
    }
    Interval.prototype.equals = function(other) {
      return this.low === other.low && this.high === other.high;
    };
    Interval.prototype.compare = function(other) {
      if (this.low < other.low && this.high < other.low) return -1;
      if (other.low < this.low && other.high < this.low) return 1;
      return 0;
    };
    function NumberAllocator(min, max) {
      if (!(this instanceof NumberAllocator)) {
        return new NumberAllocator(min, max);
      }
      this.min = min;
      this.max = max;
      this.ss = new SortedSet(
        [],
        (lhs, rhs) => {
          return lhs.compare(rhs);
        }
      );
      debugTrace("Create");
      this.clear();
    }
    NumberAllocator.prototype.firstVacant = function() {
      if (this.ss.size() === 0) return null;
      return this.ss.front().low;
    };
    NumberAllocator.prototype.alloc = function() {
      if (this.ss.size() === 0) {
        debugTrace("alloc():empty");
        return null;
      }
      const it = this.ss.begin();
      const low = it.pointer.low;
      const high = it.pointer.high;
      const num = low;
      if (num + 1 <= high) {
        this.ss.updateKeyByIterator(it, new Interval(low + 1, high));
      } else {
        this.ss.eraseElementByPos(0);
      }
      debugTrace("alloc():" + num);
      return num;
    };
    NumberAllocator.prototype.use = function(num) {
      const key = new Interval(num, num);
      const it = this.ss.lowerBound(key);
      if (!it.equals(this.ss.end())) {
        const low = it.pointer.low;
        const high = it.pointer.high;
        if (it.pointer.equals(key)) {
          this.ss.eraseElementByIterator(it);
          debugTrace("use():" + num);
          return true;
        }
        if (low > num) return false;
        if (low === num) {
          this.ss.updateKeyByIterator(it, new Interval(low + 1, high));
          debugTrace("use():" + num);
          return true;
        }
        if (high === num) {
          this.ss.updateKeyByIterator(it, new Interval(low, high - 1));
          debugTrace("use():" + num);
          return true;
        }
        this.ss.updateKeyByIterator(it, new Interval(num + 1, high));
        this.ss.insert(new Interval(low, num - 1));
        debugTrace("use():" + num);
        return true;
      }
      debugTrace("use():failed");
      return false;
    };
    NumberAllocator.prototype.free = function(num) {
      if (num < this.min || num > this.max) {
        debugError("free():" + num + " is out of range");
        return;
      }
      const key = new Interval(num, num);
      const it = this.ss.upperBound(key);
      if (it.equals(this.ss.end())) {
        if (it.equals(this.ss.begin())) {
          this.ss.insert(key);
          return;
        }
        it.pre();
        const low = it.pointer.high;
        const high = it.pointer.high;
        if (high + 1 === num) {
          this.ss.updateKeyByIterator(it, new Interval(low, num));
        } else {
          this.ss.insert(key);
        }
      } else {
        if (it.equals(this.ss.begin())) {
          if (num + 1 === it.pointer.low) {
            const high = it.pointer.high;
            this.ss.updateKeyByIterator(it, new Interval(num, high));
          } else {
            this.ss.insert(key);
          }
        } else {
          const rLow = it.pointer.low;
          const rHigh = it.pointer.high;
          it.pre();
          const lLow = it.pointer.low;
          const lHigh = it.pointer.high;
          if (lHigh + 1 === num) {
            if (num + 1 === rLow) {
              this.ss.eraseElementByIterator(it);
              this.ss.updateKeyByIterator(it, new Interval(lLow, rHigh));
            } else {
              this.ss.updateKeyByIterator(it, new Interval(lLow, num));
            }
          } else {
            if (num + 1 === rLow) {
              this.ss.eraseElementByIterator(it.next());
              this.ss.insert(new Interval(num, rHigh));
            } else {
              this.ss.insert(key);
            }
          }
        }
      }
      debugTrace("free():" + num);
    };
    NumberAllocator.prototype.clear = function() {
      debugTrace("clear()");
      this.ss.clear();
      this.ss.insert(new Interval(this.min, this.max));
    };
    NumberAllocator.prototype.intervalCount = function() {
      return this.ss.size();
    };
    NumberAllocator.prototype.dump = function() {
      console.log("length:" + this.ss.size());
      for (const element of this.ss) {
        console.log(element);
      }
    };
    module.exports = NumberAllocator;
  }
});

// node_modules/number-allocator/index.js
var require_number_allocator2 = __commonJS({
  "node_modules/number-allocator/index.js"(exports, module) {
    var NumberAllocator = require_number_allocator();
    module.exports.NumberAllocator = NumberAllocator;
  }
});

// node_modules/mqtt/build/lib/topic-alias-send.js
var require_topic_alias_send = __commonJS({
  "node_modules/mqtt/build/lib/topic-alias-send.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lru_cache_1 = require_commonjs();
    var number_allocator_1 = require_number_allocator2();
    var TopicAliasSend = class {
      aliasToTopic;
      topicToAlias;
      max;
      numberAllocator;
      length;
      constructor(max) {
        if (max > 0) {
          this.aliasToTopic = new lru_cache_1.LRUCache({ max });
          this.topicToAlias = {};
          this.numberAllocator = new number_allocator_1.NumberAllocator(1, max);
          this.max = max;
          this.length = 0;
        }
      }
      put(topic, alias) {
        if (alias === 0 || alias > this.max) {
          return false;
        }
        const entry = this.aliasToTopic.get(alias);
        if (entry) {
          delete this.topicToAlias[entry];
        }
        this.aliasToTopic.set(alias, topic);
        this.topicToAlias[topic] = alias;
        this.numberAllocator.use(alias);
        this.length = this.aliasToTopic.size;
        return true;
      }
      getTopicByAlias(alias) {
        return this.aliasToTopic.get(alias);
      }
      getAliasByTopic(topic) {
        const alias = this.topicToAlias[topic];
        if (typeof alias !== "undefined") {
          this.aliasToTopic.get(alias);
        }
        return alias;
      }
      clear() {
        this.aliasToTopic.clear();
        this.topicToAlias = {};
        this.numberAllocator.clear();
        this.length = 0;
      }
      getLruAlias() {
        const alias = this.numberAllocator.firstVacant();
        if (alias)
          return alias;
        return [...this.aliasToTopic.keys()][this.aliasToTopic.size - 1];
      }
    };
    exports.default = TopicAliasSend;
  }
});

// node_modules/mqtt/build/lib/handlers/connack.js
var require_connack = __commonJS({
  "node_modules/mqtt/build/lib/handlers/connack.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ack_1 = require_ack();
    var topic_alias_send_1 = __importDefault(require_topic_alias_send());
    var shared_1 = require_shared();
    var handleConnack = (client, packet) => {
      client.log("_handleConnack");
      const { options } = client;
      const version = options.protocolVersion;
      const rc = version === 5 ? packet.reasonCode : packet.returnCode;
      clearTimeout(client["connackTimer"]);
      delete client["topicAliasSend"];
      if (packet.properties) {
        if (packet.properties.topicAliasMaximum) {
          if (packet.properties.topicAliasMaximum > 65535) {
            client.emit("error", new Error("topicAliasMaximum from broker is out of range"));
            return;
          }
          if (packet.properties.topicAliasMaximum > 0) {
            client["topicAliasSend"] = new topic_alias_send_1.default(packet.properties.topicAliasMaximum);
          }
        }
        if (packet.properties.serverKeepAlive && options.keepalive) {
          options.keepalive = packet.properties.serverKeepAlive;
        }
        if (packet.properties.maximumPacketSize) {
          if (!options.properties) {
            options.properties = {};
          }
          options.properties.maximumPacketSize = packet.properties.maximumPacketSize;
        }
      }
      if (rc === 0) {
        client.reconnecting = false;
        client["_onConnect"](packet);
      } else if (rc > 0) {
        const err = new shared_1.ErrorWithReasonCode(`Connection refused: ${ack_1.ReasonCodes[rc]}`, rc);
        client.emit("error", err);
        if (client.options.reconnectOnConnackError) {
          client["_cleanUp"](true);
        }
      }
    };
    exports.default = handleConnack;
  }
});

// node_modules/mqtt/build/lib/handlers/pubrel.js
var require_pubrel = __commonJS({
  "node_modules/mqtt/build/lib/handlers/pubrel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var handlePubrel = (client, packet, done) => {
      client.log("handling pubrel packet");
      const callback = typeof done !== "undefined" ? done : client.noop;
      const { messageId } = packet;
      const comp = { cmd: "pubcomp", messageId };
      client.incomingStore.get(packet, (err, pub) => {
        if (!err) {
          client.emit("message", pub.topic, pub.payload, pub);
          client.handleMessage(pub, (err2) => {
            if (err2) {
              return callback(err2);
            }
            client.incomingStore.del(pub, client.noop);
            client["_sendPacket"](comp, callback);
          });
        } else {
          client["_sendPacket"](comp, callback);
        }
      });
    };
    exports.default = handlePubrel;
  }
});

// node_modules/mqtt/build/lib/handlers/index.js
var require_handlers = __commonJS({
  "node_modules/mqtt/build/lib/handlers/index.js"(exports) {
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var publish_1 = __importDefault(require_publish());
    var auth_1 = __importDefault(require_auth());
    var connack_1 = __importDefault(require_connack());
    var ack_1 = __importDefault(require_ack());
    var pubrel_1 = __importDefault(require_pubrel());
    var handle = (client, packet, done) => {
      const { options } = client;
      if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {
        client.emit("error", new Error(`exceeding packets size ${packet.cmd}`));
        client.end({
          reasonCode: 149,
          properties: { reasonString: "Maximum packet size was exceeded" }
        });
        return client;
      }
      client.log("_handlePacket :: emitting packetreceive");
      client.emit("packetreceive", packet);
      switch (packet.cmd) {
        case "publish":
          (0, publish_1.default)(client, packet, done);
          break;
        case "puback":
        case "pubrec":
        case "pubcomp":
        case "suback":
        case "unsuback":
          client.reschedulePing();
          (0, ack_1.default)(client, packet);
          done();
          break;
        case "pubrel":
          client.reschedulePing();
          (0, pubrel_1.default)(client, packet, done);
          break;
        case "connack":
          (0, connack_1.default)(client, packet);
          done();
          break;
        case "auth":
          client.reschedulePing();
          (0, auth_1.default)(client, packet);
          done();
          break;
        case "pingresp":
          client.log("_handlePacket :: received pingresp");
          client.reschedulePing(true);
          done();
          break;
        case "disconnect":
          client.emit("disconnect", packet);
          done();
          break;
        default:
          client.log("_handlePacket :: unknown command");
          done();
          break;
      }
    };
    exports.default = handle;
  }
});
export default require_handlers();
//# sourceMappingURL=mqtt_lib_handlers_index.js.map
